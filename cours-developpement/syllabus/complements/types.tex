% ============================
\chapter{Les types}
\label{chap:types}
\index{type référénce}
\index{type primitif}
% ============================

\begin{Exergue}

	«~Un \pc{type} qui se trompe en disant quelque chose de faux dit peut-être
	quelque chose de vrai.~»

	\begin{flushright}

		Philippe Geluck
		
	\end{flushright}

\end{Exergue}

En langage Java, toute donnée à un type. 

Les données manipulées dans un programme peuvent être écrites dans le code du
programme ou être mémorisées le temps de l'exécution de celui-ci ou encore être
une entrée du programme. 


\marginicon{definition}
\begin{itemize}
	\index{littéral}
	\item Une valeur écrite dans un programme est appelée
		«~\textit{littéral}~». Cette valeur une valeur et un type. 

	\item Pour qu'une valeur soit mémorisée le temps de l'exécution —~ou tout
		du moins pendant une partie de l'exécution~— elle doit être stockée
		dans une variable (voir section \vref{primitif-reference}). Une
		variable a une valeur \textit{variable} et un type. 

\end{itemize}

\minitoc

\index{type primitif}
\section{Les types primitifs}

Il existe, en Java, 8 types primitifs~: des types primitifs numériques
entiers, numériques à virgule flottante, les  caractères et les booléens.
Voici ce que dit la grammaire~: 

\begin{grammaire}
	\grammarrule{PrimitiveType:}
		\grammarrule{NumericType}
		boolean

	\grammarrule{NumericType:}
		\grammarrule{IntegralType}
		\grammarrule{FloatingPointType}

	\grammarrule{IntegralType:}
		\grammarrule{(one of)}
		byte short int long char

	\grammarrule{FloatingPointType:}
		\grammarrule{(one of)}
		float double
\end{grammaire}

Chaque type a une taille déterminée. 

La figure \vref{fig:typesprimitifs} représente tous les types primitifs en
Java. Voyons les en détails.

\begin{figure}[h]
	\centering
	\includegraphics[width=.7\linewidth]{images/primitifs.pdf}
	\caption{Les types primitifs Java}
	\label{fig:typesprimitifs}
\end{figure}

\subsection{Les types primitifs numériques entiers}

Il existe 5 types primitifs entiers. Les 4 premiers représentent des nombres
entiers signés codés en notation en complément à 2. Il s'agit des types
: \pc{\bf byte}, \pc{\bf short}, \pc{\bf int} et \pc{\bf long}. 


La quantité mathématique montrée à la figure \vref{fig:7doigts} peut être
représentée de différentes manières : en utilisant des chiffres romains —~VII~—
ou arabes en base 10 —~7~— ou en base 2 —~111~— ou encore de moult autres
façons. 

Pour représenter un nombre négatif, l'habitude est de l'affubler du signe '-'
devant mais il est également possible d'utiliser la notation en complément à 2. 

\index{byte}
\index{short}
\index{int}
\index{long}
Les types \pc{byte}, \pc{short}, \pc{int} et \pc{long} représentent une partie
des nombres entiers signés. Ils sont stockés en notation en complément à 2. Ils
se différencient par la taille qu'ils occupent en mémoire et donc par
l'intervalle de nombres qu'ils représentent. 

La figure \vref{fig:typesbyteshortintlong} rassemble les types primitifs
entiers (excepté \pc{char}) avec leurs intervalles. 

\begin{figure}[h]
	\centering
	\begin{tabular}[h]{|l|l|p{9cm}|}
		\hline
		\rowcolor{black!20}
		\textbf{Type}	&	\textbf{Taille}	&	\textbf{Intervalle}	\\
		\hline
		\pc{byte}	&	8 bits	&	[-128, 127]\\
				&			&	[$-2^7$, $2^7-1$]\\
		\pc{short}	&	16 bits	&	[-32\,768-, 32\,767]\\
				&			&	[$-2^{15}$, $2^{15}-1$]\\
		\pc{int}		&	32 bits	&	[-2\,147\,483\,648, 2\,147\,483\,647]\\
				&			&	[$-2^{31}$, $2^{31}-1$]\\
		\pc{long}	&	64 bits	
			&	[-9\,223\,372\,036\,854\,775\,808, 9\,223\,372\,036\,854\,775\,807]\\
				&			&	[$-2^{63}$, $2^{63}-1$]\\
		\hline
	\end{tabular}	
	\caption{Types primitifs entiers (exceptés \pc{char}) et leur taille}
	\label{fig:typesbyteshortintlong}
\end{figure}

Le type \pc{int} est le type numérique entier privilégié. C'est celui qui est
le plus utilisé et est le type par défaut dans les opérations mathématiques
usuelles. L'intervalle qu'il représente est généralement suffisant%
\footnote{Ce qui n'est pas toujours vrai puisqu'en décembre 2014, la vidéo \textit{Gangnam Style} est la première vidéo Youtube à dépasser ±2 milliard de vues (2\,147\,483\,647 pour être précis) et oblique Google à revoir la variable dans laquelle elle stocke ce nombre de vues pour passer à 64 bits.}. 

\begin{figure}[h]
	\centering
	\includegraphics[width=.8\linewidth]{images/7doigts.png}
	\caption{La quantité 7 montrée avec les doigts}
	\label{fig:7doigts}
\end{figure}

\subsection{Les littéraux numérique entiers (excepté \pc{char})}

Les nombres entiers sont représentés en utilisant les chiffres habituels. Il
est cependant possible d'écrire un nombre dans différentes bases. Il faudra
alors pouvoir les distinguer. En mathématiques il est d'habitude d'utiliser un
indice pour préciser la base comme : $7_{10} = 111_2$. En informatique nous
utiliseront un \textbf{préfixe}. 

\textbf{Littéral numérique décimal}

Respecte les règles suivantes~:

\begin{itemize}
	\item les chiffres \texttt{0123456789} et \texttt{\_};
	\item un littéral est de type \pc{int} ou \pc{long}, jamais de type 
		\pc{byte} ou \pc{short}\footnote{Ceci ne nous empêchera pas d'écrire 
		\pc{byte b = 5} par exemple. Nous verrons les conversions en 
		Développement II};
	\item pour distinguer un littéral \pc{long} d'un \pc{int}, suffixer 
		d'un \texttt{l} ou \texttt{L};
\end{itemize}

\textit{Exemple, la quantité 100: }
\begin{java}
	int myInt = 100;
	int myOtherIntSomeValue = 1_00;
	long myLong = 100L;
\end{java}

\textbf{Littéral numérique octal}

Respecte les règles suivantes~:

\begin{itemize}
	\item les chiffres \texttt{01234567} et \texttt{\_};
	\item commence par un \texttt{0};
	\item un littéral est de type \pc{int} ou \pc{long}, jamais de type 
		\pc{byte} ou \pc{short};
	\item pour distinguer un littéral \pc{long} d'un \pc{int}, suffixer 
		d'un \texttt{l} ou \texttt{L};
\end{itemize}

\textit{Exemple, la quantité 100: }
\begin{java}
	int myOctalInt = 0144;
	int anoherOctalInt = 01_44;
	long myOctalLong = 0144L;
\end{java}

\textbf{Littéral numérique hexadécimal}

Respecte les règles suivantes~:

\begin{itemize}
	\item les chiffres \texttt{0123456789ABCDEFabcdef} et \texttt{\_};
	\item commence par un \texttt{0x} ou \texttt{OX};
	\item un littéral est de type \pc{int} ou \pc{long}, jamais de type 
		\pc{byte} ou \pc{short};
	\item pour distinguer un littéral \pc{long} d'un \pc{int}, suffixer 
		d'un \texttt{l} ou \texttt{L};
\end{itemize}

\textit{Exemple, la quantité 100: }
\begin{java}
	int myHexadecimalInt = 0x64;
	long myHexadecimalLong = 0X64l;
\end{java}

\clearpage
\textbf{Littéral numérique binaire}

Respecte les règles suivantes~:

\begin{itemize}
	\item les chiffres \texttt{01} et \texttt{\_};
	\item commence par un \texttt{0b} ou \texttt{OB};
	\item un littéral est de type \pc{int} ou \pc{long}, jamais de type 
		\pc{byte} ou \pc{short};
	\item pour distinguer un littéral \pc{long} d'un \pc{int}, suffixer 
		d'un \texttt{l} ou \texttt{L};
\end{itemize}

\textit{Exemple, la quantité 100: } 
\begin{java}
	int myBinaryInt = 0b01100100;
	int anotherBinaryInt = 0B0110\_0100;
\end{java}

\subsection{Le type primitif numérique entier particulier \pc{char}}

Le type \pc{char} est un entier non signé de 16~bits représentant le code 
Unicode codé en UTF-16 du caractère
	\footnote{%	
		Pour en savoir plus sur l'Unicode, UTF8, UTF16 et UTF32, lire
		«~Unicode, UTF8, UTF16, UTF32\ldots et tutti quanti~» \cite{pbt-unicode}
	}. 
Un caractère Unicode codé en UTF-16 fait une taille de 16 bits ou de 32 bits en
fonction du caractère qu'il représente. Le type \pc{char} en Java ne permet de
ne représenter que le sous ensemble BMP (\textit{Basic Multilingual Plane}) des
caractères Unicodes codés en UTF-16. Ceux ayant leur code compris entre
\texttt{\textbackslash u0000} et \texttt{\textbackslash uffff}. La figure 
\vref{fig:tableunicode} montre quelques caractères et leurs code Unicode. 

\begin{figure}[h]
	\centering
	\begin{tabular}[h]{|l|l|p{9cm}|}
		\hline
		\rowcolor{black!20}
		\textbf{Type}	&	\textbf{Taille}	&	\textbf{Intervalle}	\\
		\hline
		\pc{char}	&	16 bits	&	[0, 65\,535]\\
		&			&	[$0$, $2^{16}-1$]\\
		\hline
	\end{tabular}	
	\caption{Type primitif entier \pc{char} et sa taille}
	\label{fig:typeschar}
\end{figure}

\begin{figure}[t]
	\centering
	\includegraphics[width=.75\linewidth]{../images/unicode-latin-2.png}
	\caption{Table Unicode \textit{Basic Latin (ASCII)}}
	\label{fig:tableunicode}
\end{figure}

\subsection{Les littéraux numériques entiers \pc{char}}

Un littéral de type \pc{char} se caractérise par les guillemets simples
(\textit{single quote}) qui l'entourent. 

Le caractère \textit{a} par exemple, se représente \texttt{'a'}. Et l'on pourra
déclarer une variable de type \pc{char} et l'initialiser avec le caractère
\textit{a} par une instruction de la forme~:

\begin{java}
	char myChar = 'a';
\end{java}

La variable \pc{myChar} de type \pc{char} est initialisée avec le littéral
\pc{'a'} de type \pc{char} également. 


\clearpage
\marginicon{definition}
\index{séquence d'échappement}
À ceci s'ajoute la possibilité \textbf{d'échapper des caractères}. Un caractère
peut parfois avoir plusieurs significations. Par exemple le caractère
\textit{single quote} (\pc{'}) signale le début d'un littéral de type \pc{char}
mais peut vouloir signaler simplement le caractère~\pc{'}.   
Comment distinguer les deux ?

Lorsque l'on écrit simplement un caractère, il a sa signification habituelle~: 
\texttt{a} signifie \textit{a},
\texttt{b} signifie \textit{b},
\texttt{Z} signifie \textit{Z},
\texttt{'} signifie \textit{voici le début ou la fin d'un caractère}, etc. 
Certains caractères ont un \textbf{deuxième sens} lorsque qu'ils sont 
\textit{échappés}, c'est-à-dire précédés d'un \textit{backslash} 
(\pc{\textbackslash}). La figure \vref{tab:séquenceséchappements} montre les 
principaux.

\begin{figure}[h]
	\centering
	\begin{tabular}[h]{|l|p{6cm}|l|}
		\hline
		\rowcolor{black!20}
		\textbf{Caractère}	&	\textbf{Sens premier}	& \textbf{Sens second}	\\
		\hline
		n					&	n						& passage à la ligne	\\
		t					&	t						& tabulation		\\
		'					&	début ou fin d'un littéral \pc{char}	
														&	'	\\
		"					& 	début ou fin d'une chaine 	
														&	"	\\
		\textbackslash		& 	signale une séquence d'échappement 
								(ou \textit{attention, le caractère qui suit 
								n'a pas son sens premier}) 	
														&	\textbackslash	\\
		\hline
	\end{tabular}
	\caption{Quelques séquences d'échappement (la liste complète \cite{jls9} section 3.10.6)}
	\label{tab:séquenceséchappements}
\end{figure}



\subsection{Les types primitifs numériques à virgule flottante}

Les nombres pseudo-réels, ou encore les nombres à virgule flottante, sont un
sous ensemble des réels parce que —\,comme pour les entiers\,— il y aura un
\textit{plus petit nombre représentable} et \textit{un plus grand}. C'est
l'\textbf{intervalle} de nombre que l'on peut représenter. À ceci, s'ajoute la
\textbf{précision} que l'on pourra atteindre. En effet, les réels est un
ensemble continu de nombre —\,entre deux nombre réels, il existe toujours, au
moins, un autre réel\,— tandis que les pseudo-reéls est un ensemble discret. 

Les nombres à virgule flottante (\textit{floating numbers}) sont codés suivant
la norme \href{https://fr.wikipedia.org/wiki/IEEE_754}{IEEE\,754}. 

Selon cette norme, un nombre est représenté avec un signe, une mantisse et un
exposant. Le tout en base 2. Un bit est utilisé pour le signe.  

\[
	nombre = signe~mantisse_2~2^{exposant_2} 
\]

Il existe 2 types primitifs à virgule flottante~: \textbf{\texttt{float}} et
\textbf{\texttt{double}} dont les tailles sont données à la figure
\vref{fig:typefloat}.

\begin{figure}[h]
	\centering
	\begin{tabular}[t]{|l|c|c|c|}
		\hline
		\rowcolor{black!40}
		\textbf{Type} 	& \textbf{Taille (\textit{bit})}	
								& \textbf{Exposant} & \textbf{Mantisse}\\
		\hline
		float	& 32 bits					& 8		& 23\\
		\hline
		double	& 64 bits					& 11	& 52\\
		\hline
	\end{tabular}
	\caption{Types primitifs numériques à virgule flottante et leur taille}
	\label{fig:typefloat}
\end{figure}



\subsection{Les littéraux numériques à virgule flottante}

Les littéraux à virgule flottante sont composés de plusieurs parties~: une
partie entière, un point décimal (ou hexadécimal), une partie décimale, un
exposant et un suffixe.

\bigskip
\begin{center}
	\large\bf	| partie entière | . | partie décimale | exposant | suffixe |
\end{center}
\bigskip

Un littéral à virgule flottante peut être exprimé en base 10 (décimal) ou en 
base 16 (hexadécimal). 

Un littéral à virgule flottante est de type \pc{float} s'il est suffixé d'un
\pc{f} ou \pc{F} sinon, il est de type \pc{double}. Et ce qu'il soit suffixé
d'un \pc{d} ou \pc{D} ou non. 

Pour un \textbf{littéral décimal à virgule flottante}, au minimum un chiffre
dans la partie entière ou décimale et soit le point décimal, soit l'exposant,
soit le suffixe sont requis. Les autres parties sont optionnelles. 

\begin{itemize}

	\item la partie entière et la partie décimale sont des littéraux décimaux
		entiers (le caractère \pc{\_} étant autorisé);

	\item le point décimal est un point (\pc{.});

	\item l'exposant est la lettre \pc{e} ou \pc{E} suivie par un littéral
		décimal entier (le caractère \pc{\_} étant autorisé);

	\item le suffixe est \pc{f}, \pc{F}, \pc{d} ou \pc{D}

\end{itemize}

\textit{Exemples:}
\begin{java}
	double myDouble;
	myDouble = 1.;			// 1.0
	myDouble = .1;			// 0.1
	myDouble = 1e1;			// 10.0
	myDouble = 1d;			// 1.0
	myDouble = 1.e0;		// 1.0
	myDouble = 1_000.45;	// 1000.45
	myDouble = 1.45e3;		// 1450.0
	myDouble = .45e3d;		// 450.0
	
	float myFloat;
	myFloat = 1f;			// 1.0
	myFloat = 1.f			// 1.0	
\end{java}

Pour un \textbf{littéral hexadécimal à virgule flottante}, au minimum un
chiffre dans la partie entière ou décimale et l'exposant sont obligatoires. Le
suffixe est optionnel. 

\begin{itemize}

	\item le littéral débute par \pc{0x} ou \pc{0X};

	\item la partie entière et la partie décimale sont des chiffres hexadécimaux
		(le caractère \pc{\_} étant autorisé);

	\item le point décimal est un point (\pc{.});

	\item l'exposant est la lettre \pc{p} ou \pc{P} suivie par un littéral
	\marginicon{attention}
		décimal entier (le caractère \pc{\_} étant autorisé) représentant une 
		puissance de 2;

	\item le suffixe est \pc{f}, \pc{F}, \pc{d} ou \pc{D}

\end{itemize}

\textit{Exemples:}
\begin{java}
	double myDouble;
	myDouble = 0x1p0;		// 1.0 = 1 * 2^0
	myDouble = 0x1.1p0;	// 1.0625 = 1 + (1/16)
	myDouble = 0x1p1;		// 2.0 = 1 * 2^1
	myDouble = 0xA.Bp0; // 10.6875= 10 + 11*1/16
	myDouble = 0x1E2p2; // 1928 = (1*16^2 + 14*16^1 + 2*16^0) * 2^2

	float myFloat;
	myFloat = 0X.1p4f;		// 1.0 = (1*16^-1) * 2^4

\end{java}




\subsection{Le type primitif booléen}

Le type primitif booléen permet de représenter les deux valeurs logiques
\textit{vrai} et \textit{faux}. Ce sont les deux seules valeurs de ce type. 


\subsection{Les littéraux booléens}

Les littéraux booléens sont simplement~: \pc{true} pour \textit{vrai} et
\pc{false} pour \textit{faux}. 

\pagebreak[2]
\textit{Exemple:}
\nopagebreak
\begin{java}
	boolean myBoolean = true;
\end{java}










\index{type référence}
\section{Les types références}

Pour rappel (cfr. section \vref{primitif-reference}) une variable de type
référence est une variable qui ne contient pas directement la valeur qui lui
est assignée mais une référence vers cette valeur (qui se trouve à un autre
endroit).  

Tous les types qui ne sont pas un des 8 types primitifs présentés à la section
précédente sont des types références. Ce sont les types les plus répandus bien
que nous n'en verrons que quelques-uns dans ce premier cours de développement. 

Dans cette section, nous parlerons essentiellement de \texttt{String} et de
\textit{tableaux} bien que l'on ait déjà rencontré d'autres types références
comme \texttt{Scanner} ou \texttt{Random}. Pas d'inquiétude, nous règlerons
leur compte plus tard, en développement II. 

\clearpage
\subsection{Le type référence \texttt{String}}

\texttt{String} est un type référence. 

\begin{wrapfigure}{r}{.3\linewidth}
	\begin{center}
	\begin{tikzpicture}
		\node[draw, minimum width=.5cm, 
			minimum height=.5cm,label={above:\texttt{s}}] (ref) {};
		\node[draw, below of=ref, right] (string) at (0,0) {Hello};
		\draw[->] (ref.center) -- (string);
	\end{tikzpicture}
	\end{center}
\end{wrapfigure}

Pour rappel, déclarer une variable de type \texttt{String} a pour effet de
réserver un emplacement mémoire sur la pile (\textit{stack}). Initialiser cette
variable avec une valeur a pour effet de placer cette valeur sur le tas
(\textit{heap}). La variable \textit{référencera} cette valeur comme nous
pouvons le voir sur la figure ci-contre. 

La variable \texttt{s} se trouve sur la pile. 

La valeur \textit{"Hello"} se trouve sur le tas. 

Il est bien sûr possible de changer la valeur d'une variable de type référence,
et dans ce cas, c'est la référence qui change. Si la valeur initiale de
\texttt{s} est \textit{Hello} et qu'elle devient \textit{Bye bye}, la situation
sera par exemple comme illustré à la figure \vref{fig:hellobyebye}. Nous
y reviendrons. 

\begin{figure}[h]
	\centering
	\begin{tikzpicture}
		\node[draw, minimum width=.5cm, 
			minimum height=.5cm,label={above:\texttt{s}}] (ref) {};
		\node[draw, below of=ref, right] (string) at (0,0) {Hello};
		\node[draw, below of=string] (string2) at (3, 0) {Bye bye};
		\draw[->] (ref.center) -- (string2);
	\end{tikzpicture}
	\caption{Exemple : \texttt{s} reçoit \textit{Hello} et ensuite {Bye bye}}
	\label{fig:hellobyebye}
\end{figure}



\subsection{Les littéraux de type \texttt{String}}

Un littéral de type \texttt{String} se caractérise par les guillemets doubles
(\textit{double quote}) qui l'entourent (voir \cite{jls9} section 3.10.5). 

La chaine \textit{Hello} par exemple, se représente \texttt{"Hello"}. Et l'on
pourra déclarer une variable de type \texttt{String} et l'initialiser avec la
chaine \textit{Hello} par une instruction de la forme~:

\begin{java}
	String myString = "Hello";
\end{java}

Une chaine de caractères peut contenir n'importe quel caractère en ce compris,
des caractères d'échappement. La chaine \texttt{"Hello\textbackslash nWorld"}
a donc un sens et en cas d'affichage de cette chaine, nous verrons un passage
à la ligne entre \textit{Hello} et \textit{World}.  

Un littéral de type \texttt{String} donné —~par exemple
\texttt{"Hello"}~— référence toujours le même emplacement mémoire. Par exemple,
le code suivant s'illustre par la figure \vref{fig:somehello}. 

\begin{java}
	String s1 = "Hello";
	String s2 = "Hello";
\end{java}

\begin{figure}[h]
	\centering
	\begin{tikzpicture}
		\node[draw, minimum width=.5cm, 
			minimum height=.5cm,label={above:\texttt{s1}}] (ref1) {};
		\node[draw, minimum width=.5cm, 
			minimum height=.5cm,label={above:\texttt{s2}}] (ref2) at (1,0) {};
		\node[draw, below of=ref2, right] (string) at (2,-0.5) {Hello};
		\draw[->] (ref1.center) -- (string);
		\draw[->] (ref2.center) -- (string);
	\end{tikzpicture}
	\caption{Exemple : \texttt{s1} et \texttt{s2} reçoivent \textit{Hello}}
	\label{fig:somehello}
\end{figure}

\textbf{Remarque}~: ceci est vrai pour les littéraux de type \texttt{String}
pas pour des valeurs de type \texttt{String} qui seraient, par exemple, reçues
au \textit{runtime}. 

Le code suivant par exemple s'illustrerait par la figure
\vref{fig:differenthello}. 

\begin{java}
	Scanner keyboard = new Scanner(System.in);
	String s1 = keyboard.nextLine();	// INPUT Hello
	String s2 = keyboard.nextLine();	// INPUT Hello
\end{java}

\begin{figure}[h]
	\centering
	\begin{tikzpicture}
		\node[draw, minimum width=.5cm, 
			minimum height=.5cm,label={above:\texttt{s1}}] (ref1) {};
		\node[draw, minimum width=.5cm, 
			minimum height=.5cm,label={above:\texttt{s2}}] (ref2) at (1,0) {};
		\node[draw, below of=ref2, right] (string1) at (3,0) {Hello};
		\node[draw, below of=ref2, right] (string2) at (3,-1) {Hello};
		\draw[->] (ref1.center) -- (string2);
		\draw[->] (ref2.center) -- (string1);
	\end{tikzpicture}
	\caption{Exemple : \texttt{s1} et \texttt{s2} reçoivent \textit{Hello}}
	\label{fig:differenthello}
\end{figure}





\index{tableau}
\subsection{Les types références \textit{tableau}}

Les tableaux sont tous de types références. 

Pour rappel (cfr. section~\vref{chap:tableaux}), \textbf{déclarer} un
variable de type \textit{tableau de} a pour effet de réserver un emplacement
mémoire sur la pile (\textit{stack}). \textbf{Créer} le tableau réservera
l'emplacement mémoire sur le tas (\textit{heap}) et l'initialiser placera les
valeurs dans les cases du tableau comme illustré sur la figure \vref{fig:array1}. 

\begin{figure}[h]
	\centering
	\begin{tikzpicture}
		\node[draw, minimum width=.5cm, 
			minimum height=.5cm,label={above:\texttt{is}}] (ref1) {};
		\node[draw, minimum width=1cm,
			minimum height=1cm, below of=ref1, right] at (.5,-.5) (case1) {3};
		\node[draw, minimum width=1cm,
			minimum height=1cm, right of=case1]  (case2) {-14};
		\node[draw, minimum width=1cm,
			minimum height=1cm, right of=case2]  (case3) {15};
		\draw[->] (ref1.center) -- (case1);
	\end{tikzpicture}
	\caption{Exemple : \texttt{is} est un tableau de \texttt{int} (par exemple) ayant reçu les valeurs 3, -14 et 15 }
	\label{fig:array1}
\end{figure}

Il est bien sûr possible de changer la valeur d'un élément du tableau, voire
même de changer la valeur du tableau. 

% Déclaration
\begin{minipage}[t]{.5\linewidth}
	\textbf{Déclaration} du tableau \texttt{is}. 

	C'est un tableau d'entiers. Déclaré par~:
	\medskip
	\begin{java}
int[] is;
	\end{java}
\end{minipage}
\quad
\begin{minipage}[t]{.5\linewidth}
	\centering
	\vspace{.5cm}
	\begin{tikzpicture}
		\node[draw, minimum width=.5cm, 
			minimum height=.5cm,label={above:\texttt{is}}] (ref1) {};
	\end{tikzpicture}
\end{minipage}

\bigskip

% Création
\begin{minipage}[t]{.5\linewidth}
	\textbf{Création} du tableau d'entiers et \textbf{initialisation}. 
	La variable \texttt{is} contient une référence vers la mémoire qui contient
	le tableau.
	\medskip

	\begin{java}
int[] is = {3, -14, 15};
				
	\end{java}
\end{minipage}
\quad
\begin{minipage}[t]{.5\linewidth}
	\centering
	\vspace{.1cm}
	\begin{tikzpicture}
		\node[draw, minimum width=.5cm, 
			minimum height=.5cm,label={above:\texttt{is}}] (ref1) {};
		
		\node[draw, minimum width=1cm,
			minimum height=1cm, below of=ref1, right] at (.5,-.5) (case1) {3};
		\node[draw, minimum width=1cm,
			minimum height=1cm, right of=case1]  (case2) {-14};
		\node[draw, minimum width=1cm,
			minimum height=1cm, right of=case2]  (case3) {15};
		
		\draw[->] (ref1.center) .. controls(-1,-3) .. (case1);
	\end{tikzpicture}
\end{minipage}


\begin{minipage}[t]{.5\linewidth}
	\textbf{Remplacement} d'une valeur de type primitif dans le tableau. 
	La variable \texttt{is[0]}, de type primitif (\texttt{int}) reçoit directement
	une nouvelle valeur. 
	\medskip

	\begin{java}
int[] is = {3, -14, 15}
is[1] = 14;
	\end{java}
	\vspace{1cm}
\end{minipage}
\quad
\begin{minipage}[t]{.5\linewidth}
	\centering
	\vspace{.1cm}
	\begin{tikzpicture}
		\node[draw, minimum width=.5cm, 
			minimum height=.5cm,label={above:\texttt{is}}] (ref1) {};
		
		\node[draw, minimum width=1cm,
			minimum height=1cm, below of=ref1, right] at (.5,-.5) (case1) {3};
		\node[draw, minimum width=1cm,
			minimum height=1cm, right of=case1]  (case2) {\textbf{14}};
		\node[draw, minimum width=1cm,
			minimum height=1cm, right of=case2]  (case3) {15};
		
		\draw[->] (ref1.center) .. controls(-1,-3) .. (case1);
	\end{tikzpicture}
	\vspace{-2cm}
\end{minipage}

\bigskip

\begin{minipage}[t]{.5\linewidth}
	\textbf{Remplacement} du tableau par un autre tableau. 
	La variable \texttt{is}, de type référence (\texttt{int[]}), reçoit une 
	référence vers le nouveau tableau. 
	\medskip
	\begin{java}
int[] is = {3, -14, 15};
is[0] = 14;
is = new int[] {-2, 71, 82, 81};
	\end{java}
	\vspace{1cm}
\end{minipage}
\quad
\begin{minipage}[t]{.5\linewidth}
	\centering
	\vspace{.1cm}
	\begin{tikzpicture}
		\node[draw, minimum width=.5cm, 
			minimum height=.5cm,label={above:\texttt{is}}] (ref1) {};
		
		\node[draw, minimum width=1cm,
			minimum height=1cm, below of=ref1, right] at (.5,-.5) (case1) {3};
		\node[draw, minimum width=1cm,
			minimum height=1cm, right of=case1]  (case2) {14};
		\node[draw, minimum width=1cm,
			minimum height=1cm, right of=case2]  (case3) {15};
		
		\node[draw, minimum width=1cm,
			minimum height=1cm, below of=ref1, right] at (.5,-2.5) (case21) {-2};
		\node[draw, minimum width=1cm,
			minimum height=1cm, right of=case21]  (case22) {71};
		\node[draw, minimum width=1cm,
			minimum height=1cm, right of=case22]  (case23) {-82};
		\node[draw, minimum width=1cm,
			minimum height=1cm, right of=case23]  (case24) {81};
		\draw[->] (ref1.center) .. controls(-1,-3) .. (case21);
	\end{tikzpicture}
\end{minipage}



\subsection{Durée de vie des données sur le tas}

Les données de type référence sont créées sur le tas. Chaque fois que l'on crée
un tableau, une nouvelle chaine ou une nouvelle donnée de type référence, un
emplacement mémoire est réservé sur le tas pour contenir les valeurs. La
variable contiendra une référence vers ces valeurs. 

Nous avons vu qu'il était possible de changer la valeur d'une variable de type
référence. Dans ce cas, l'ancienne valeur n'est plus référencée. Lorsque plus
aucune variable ne référence une valeur en mémoire, elle n'est plus utile
à personne. Comment la récupérer pour libérer de l'espace mémoire qui, bien que
grand, n'est pas infini ?

Dans certains langages, c'est la tâche du développeur ou de la développeuse de
\textit{libérer} les emplacements mémoires qu'iel n'utilise plus. Dans d'autres
langages, c'est le langage qui s'en occupe. 

En langage Java, c'est le langage qui se charge de la gestion de la mémoire.
Lorsqu'il le décide, il lance un programme qui s'appelle le ramasse-miette
(\textit{garbage collector}\footnote{Notez que la traduction n'est pas
littérale.}) qui parcourt la mémoire à la recherche des valeurs non référencées
et rend les emplacements mémoires à nouveau disponibles. Il est possible de
demander explicitement le passage du ramasse-miette mais ce sera la machine
virtuelle qui décidera de son passage ou non. 




