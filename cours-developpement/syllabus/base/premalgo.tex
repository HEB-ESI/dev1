%========================================================
\chapter{Premiers algorithmes}
\label{premalgos}
%==========================================================

	Dans le chapitre précédent, vous avez appris à analyser un problème et
	à clairement le spécifier.  Il est temps d’écrire des solutions.  Pour cela,
	nous allons devoir trouver comment passer des données au résultat et
	l’exprimer dans un langage compris de tous.
	
	En fonction de la difficulté du problème et de notre sensibilité, nous
	pouvons représenter un algorithme de plusieurs manières; en langage naturel
	(en français ou en 	anglais), en pseudocode ou avec un organigramme\ldots
	Dans ce chapitre, nous présenterons les algorithmes en langage naturel, en
	pseudocode, avec un organigramme et en langage Java. 

	Dans la suite du cours, nous nous contenterons de les écrire en langage Java. 

	\newpage
	\minitoc
	\newpage
	
	%================================================
	\section{Exercice résolu~: un problème simple}
	\label{exerciceresolu}
	%================================================
	
		%===================================
		\subsection{Trouver l’algorithme}
		%=================================

			Illustrons notre propos sur l’exemple qui a servi de fil conducteur
			tout au long du chapitre précédent.  Rappelons l’énoncé et l’analyse
			qui en a été faite.
			
			\begin{Emphase}
				\paragraph{Problème.}
				Calculer la surface d’un rectangle 
				à partir de sa longueur et sa largeur.
			
				\paragraph{Analyse.} 
				Nous sommes arrivés à la spécification suivante~:
				\begin{center}
				\flowalgodd{longueur (réel positif)}
				{largeur (réel positif)}{surfaceRectangle}{réel}
				\end{center}

				ou encore~:
			
				\begin{center}
				\begin{tabular}[t]{|>{\columncolor{black!40}}r|l|}
				\hline
				\textbf{Données} & \makecell[tl]{
					longueur (un réel positif)\\
					largeur (un réel positif)
				}\\
				\hline
				\textbf{Résultat} & la surface du rectangle\\
				\hline
				\end{tabular}
				\end{center}
				
				\textbf{Exemples.} % paragraph casse la mise en page
			
				La surface du rectangle 3,2 vaut 6. La surface du rectangle 3.5,
				1 vaut 3.5. 

				ou 

				\begin{multicols}{2}
					\begin{itemize}
					\item \pc{rectangleArea(3,2)} donne $6$~;
					\item \pc{rectangleArea(3.5,1)} donne $3.5$.		
					\end{itemize}
				\end{multicols}

				ou

				\begin{center}
					\begin{tabular}[t]{|l|c|c|}
						\hline						
						\cellcolor{black!40}\textbf{Données}&&\\
						\hline
						L	&	3	& 3.5\\
						l	&   2	& 1\\
						\hline
						\cellcolor{black!40}\textbf{Résultat}& 6 & 3.5\\
						\hline
					\end{tabular}
				\end{center}
			\end{Emphase}
			
			Les exemples sont essentiels. Ce sont eux qui vont nous permettre de
			tester notre algorithme. Notre programme. 

			\paragraph{Comment résoudre ce problème~?} 
			La toute première étape est de comprendre 
			le lien entre les données et le résultat. 
			Ici, le lien est la formule du calcul d'une surface.  
			
			\[
				\textrm{surface} = \textrm{longueur} * \textrm{largeur}
			\]

			La surface s’obtient donc en multipliant la longueur par la largeur%
			\footnote{%
				Trouver la bonne formule n’est pas toujours facile.
				Dans votre vie professionnelle, 
				vous devrez parfois écrire un algorithme
				pour un domaine que vous connaissez peu,
				voire pas du tout.
				Il vous faudra alors chercher de l’aide,
				demander à des experts du domaine.
				Dans ce cours,
				nous nous concentrons sur des problèmes simples.
			}.
		
		%===================================
		\subsection{Vérifier l’algorithme}
		\index{vérifier un algorithme}
		%=================================
	
			Une étape importante, après l'écriture d'un algorithme est la
			vérification de sa validité. Il est important d'exécuter
			l’algorithme avec des exemples numériques et vérifier que chaque 
			réponse fournie est correcte.

			Pour tester un algorithme il faut — même si ça parait étrange
			— \textbf{éteindre son cerveau}.  Il faut agir comme une machine et
			exécuter \textbf{ce qui est écrit} pas ce que l'on voulait écrire ou
			ce que l'on pensait avoir écrit ou encore ce qu’il est censé faire.
			Cela demande un peu de pratique.

			\paragraph{Exemple.} 
			Vérifions notre solution 
			pour le calcul de la surface du rectangle
			en reprenant les exemples choisis.
			
			\begin{center}
			\begin{tabular}{|c|cccc|c|}
			\hline
			\rowcolor{black!40}
			test \no & longueur & largeur & réponse attendue 
				& réponse fournie & {} \\
			\hline 
			1 & 3   & 2 & 6   & 6   & {\color{ForestGreen}$\checkmark$} \\\hline
			2 & 3.5 & 1 & 3.5 & 3.5 & {\color{ForestGreen}$\checkmark$} \\\hline
			\end{tabular}
			\end{center}				
		


		%===================================
		\subsection{Écrire l’algorithme}
		%=================================

		\subsubsection{Langage naturel}

			En \textbf{langage naturel}, une solution aurait simplement cette 
			allure~:

			\begin{langagenaturel}
				La surface s'obtient grâce à la formule~:
				\[
					surface = longueur * largeur
				\]
			\end{langagenaturel}

		\subsubsection{Organigramme}

			Un \textbf{organigramme} d'une solution aura cette allure~:

			\begin{center}
			\begin{tikzpicture}[node distance=2cm]
			\node (start) [startstop] {Aire d'un rectangle};
			\node (in1) [io, below of=start] {
				\pc{length}\\
				\pc{width}
			}; 
			\draw [arrow] (start) -- (in1);
			\node (pro1) [process, below of=in1] {
				\pc{rectangleArea = length * width}
			};
			\draw [arrow] (in1) -- (pro1);
			\node (stop) [startstop, below of=pro1] {Fin};
			\draw [arrow] (pro1) -- (stop);
			\end{tikzpicture}
			\captionof{Organigramme}{Solution de \pc{rectangleArea}}
			\end{center}
			
		\subsubsection{Pseudocode}
			
			Un \textbf{pseudocode} d'une solution s’écrit :
			
			\begin{pseudocode}
				\Algo{rectangleArea}{\Par{length, width}{reals}}{real}
					\Return length * width
				\EndAlgo
			\end{pseudocode}
		
			Le mot \pc{\algorithmicalgo} et l'\textbf{indentation} — soulignée
			par une ligne verticale — permettent de délimiter l’algorithme.  La
			première ligne est appelée \textbf{l’entête}\index{entête} de
			l’algorithme.  On y retrouve :

			\begin{itemize}
				\item 
					le nom de l’algorithme,
				\item 
					une déclaration des données, 
					qu’on appellera ici les \textbf{paramètres}, 
				\item 
					le type du résultat.
			\end{itemize}
		
			Les paramètres recevront des valeurs concrètes
			au \textbf{début} de l’exécution de l’algorithme. 
		
			L’instruction \pc{\algorithmicreturn}\index{return}
			permet d’indiquer la valeur du résultat, 
			ce que l’algorithme \emph{retourne}.
			Si on spécifie une formule, un calcul,
			c’est le \textbf{résultat} (on dit l’\emph{évaluation}) 
			de ce calcul qui est retourné et \textbf{pas la formule}.
		
			Pour indiquer le calcul à faire, écrivez-le, naturellement comme
			vous le feriez en mathématique.  
	
			Pour demander l'\textbf{exécution} d'un algorithme (on dit aussi
			\emph{appeler}) il suffit d’indiquer son nom et les valeurs
			concrètes à donner aux paramètres.  Ainsi,
			\pc{rectangleArea(6,3)} fait appel à l’algorithme correspondant
			pour calculer la surface d’un rectangle dont la longueur est $6$ et
			la largeur est $3$.

			Dans ces notes, nous utiliserons «~\pc{$\rightarrow$}~» pour montrer
			ce que retourne l'algorithme mais «~\pc{:}~» ou un simple
			«~\pc{\large\textvisiblespace}~»\footnote{Ce symbole signifie: «~ici
			se trouve un espace~»} font l'affaire.

		\subsubsection{Java}
		\index{implémenter un algorithme}

			Une solution en Java s'écrit~:

			\begin{java}
public class RectangleArea{
	public static double rectangleArea(double length, double width){
		return length * width;
	}
}			
			\end{java}

			Telle quelle la solution n'est pas fonctionnelle en ce sens que 
			l'éxécution du programme ne montrera aucun résultat à l'écran. 
			
			Le \textbf{point d'entrée}\index{point d'entrée} d'un programme en
			Java est la méthode \textbf{\texttt{main}}. Cette méthode est la
			première qui sera exécutée. Elle est obligatoire si l'on veut pouvoir
			exécuter le programme. 

			Au minimum, si l'on veut calculer et afficher l'aire d'un rectangle
			de longueur 3 et de largeur 2, il faudrait plutôt écrire~:

			\begin{java}
public class RectangleArea{
	public static double rectangleArea(double length, double width){
		return length * width;
	}

	public static void main(String[] args){
		System.out.println(rectangleArea(3,2));
	}
}
			\end{java}

		%===================================
		\subsection{Remarques}
		%=================================
		%
			\marginicon{attention}
			\textbf{Attention} : 
	
			Écrire une solution complète d'un exercice c'est~:
			\begin{itemize}
				\item spécifier le problème~;
				\item fournir des exemples, les tests~;
				\item construire son algorithme~;
				\item tester le programme et constater qu'il fournit bien les 
					résultats attendus
			\end{itemize}


		%-------------------------------------------
		\section{Résolution d'un second problème simple}
		\label{prem-ex-simple}
		%-------------------------------------------

			\marginicon{fiche}	
			
			Vous pouvez vous baser sur la fiche \vref{fiche:calcul-simple} qui
			résume la résolution du calcul de la surface d’un rectangle, depuis
			l’analyse de l’énoncé jusqu’à l’algorithme et à sa vérification.
	
			\begin{Emphase}
				
				\paragraph{Problème.}
				Calculer la somme de deux nombres donnés.

				\paragraph{Analyse.}
				\begin{center}
					\flowalgodd{nombre1 (réel)}{nombre2 (réel)}{somme}{réel}
				\end{center}

				ou~:

				\begin{center}
				\begin{tabular}[t]{|>{\columncolor{black!40}}r|l|}
				\hline
				\textbf{Données} & \makecell[tl]{
					nombre 1 (un nombre réel quelconque)\\
					nombre 2 (un autre nombre réel)
				}\\
				\hline
				\textbf{Résultat} & la somme des deux nombres\\
				\hline
				\end{tabular}
				\end{center}
			
				\paragraph{Exemples}

				Les exemples qui deviendront les tests~:

				\begin{center}
				\begin{tabular}{|c|cccc|}
				\hline
				\rowcolor{black!40}
				test \no & nombre1 & nombre2 & réponse attendue 
				  & réponse fournie \\
				\hline 
				1 & 3    & 2   & 5   & 5   
					 \\\hline
				2 & -3   & 2   & -1  & -1  
					 \\\hline
				3 & 3    & 2.5 & 5.5 & 5.5 
					 \\\hline
				4 & -2.5 & 2.5 & 0   & 0   
					\\\hline
				\end{tabular}
				\end{center}

				\paragraph{Algorithme}

				L’algorithme s’écrit simplement en langage naturel :

				\begin{langagenaturel}
					somme = n1 + n2
				\end{langagenaturel}

				La traduction en un programme Java est très semblable au 
				premier exemple. 

				\begin{java}
public class Addition{
	public static double add(double number1, double number2){
		return number1 + number2;
	}
}			
				\end{java}

				
				\paragraph{Tester le programme}
				
				Il est aussi assez facile de vérifier qu’il fournit
				bien les bonnes réponses pour les exemples choisis.				


				\begin{center}
				\begin{tabular}{|c|cccc|c|}
				\hline
				\rowcolor{black!40}
				test \no & nombre1 & nombre2 & réponse attendue 
				  & réponse fournie & {} \\
				\hline 
				1 & 3    & 2   & 5   & 5   
					& {\color{ForestGreen}$\checkmark$} \\\hline
				2 & -3   & 2   & -1  & -1  
					& {\color{ForestGreen}$\checkmark$} \\\hline
				3 & 3    & 2.5 & 5.5 & 5.5 
					& {\color{ForestGreen}$\checkmark$} \\\hline
				4 & -2.5 & 2.5 & 0   & 0   
					& {\color{ForestGreen}$\checkmark$} \\\hline
				\end{tabular}
				\end{center}				

			\end{Emphase}
		
	
	
	
	%=========================================================================
	\section{Décomposer les calculs; variables et assignation}
	%=========================================================================
	
		Pour pouvoir décomposer un calcul un peu long en plusieurs étapes
		nous devons introduire deux nouvelles notions :
		les \emph{variables locales} et \emph{l’assignation}.

		Par exemple le calcul d'un prix TTC (toutes taxes comprises) d'un
		ensemble de produits dont on connait la quantité et le prix unitaire
		hors taxe, peut se décomposer en le calcul du prix unitaire TTC et,
		ensuite, en le calcul du prix total. 

		%-----------------------------------------
		\subsection{Les variables}\index{variable}
		%-----------------------------------------
		
			\marginicon{definition} 
			Une \textbf{variable}\index{variable} est une zone mémoire munie
			d'un nom et qui contiendra une valeur d’un type donné.  Cette valeur
			\emph{peut} évoluer au fil de l'avancement de l'algorithme ou du
			programme.  Elle sert à retenir des étapes intermédiaires de
			calculs.

			Les variables peuvent être \textbf{locales} ou \textbf{globales}.

			\begin{itemize}
				
				\item Une \textbf{variable locale}\index{variable locale} n'est
					connue et utilisable qu'au sein de l'algorithme où elle est
					déclarée. 

					En Java, une variable locale n'est connue que dans le
					\emph{bloc} d'instructions dans lequel elle est déclarée.
					Un bloc d'instructions \index{bloc} est un ensemble
					d'instructions délimitées par une paire d'accolades. 

				\item Une \textbf{variable globale}\index{variable globale} est 
					connue dans tous les algorithmes d'un même problème. 

					En Java, une variable globale est connue de toutes les
					classes et les méthodes d'un même projet. Nous y reviendrons. 

			\end{itemize}
				
			Dans nos algorithmes et dans nos programmes nos variables  seront
			toujours locales. 

			Pour être utilisable, une variable doit être \emph{déclarée} au
			début de l’algorithme. La \textbf{déclaration}\index{déclaration}
			d’une variable est l’instruction qui définit son nom et son type.
			On pourrait écrire~:

			\begin{langagenaturel}
				Longueur et largeur seront les noms de deux 
				objets destinés à recevoir
				
				Les longueur et largeur du rectangle, 
				c’est-à-dire des nombres à valeurs réelles.
				
			\end{langagenaturel}
	
			Nous pouvons abréger -- et passer à l'anglais -- en~:

			\begin{langagenaturel}
				réels length, width
			\end{langagenaturel}
	
			Certains langages de programmation imposent que les variables soient 
			déclarées — c'est le cas de Java — et le vérifient tandis que d'autres 
			permettent d'utiliser des variables sans les déclarer. 
			
			Dans ce premier cours de développement, nous déclarerons toujours nos
			variables avant de les utiliser. Principalement dans un soucis de
			lisibilité et également car ceci évite des erreurs lors de
			l'élaboration des algorithmes et des programmes.  

			En langage Java, cela donne~:

			\begin{java}
double length, width;
			\end{java}

			Par convention, Java privilégie une déclaration par ligne, comme 
			ceci~:
			
			\begin{java}
double length;
double width;
			\end{java}
			
			Pour choisir le nom d’une variable, les règles sont les mêmes que
			pour les données d’un problème.


			\pagebreak
		%-----------------------------------------
		\subsection{L’assignation}\index{assignation}
		%--------------------------------------------
	
			\marginicon{definition}
			L’\textbf{assignation}\index{assignation}
			(on dit aussi \emph{affectation interne}\index{affectation interne})
			est une instruction qui donne une valeur 
			à une variable ou la modifie.
	
			Cette instruction est probablement la plus importante
			car c’est ce qui permet de retenir les résultats 
			de calculs intermédiaires.

			Pour cette assignation, nous pourrions utiliser une flèche
			$\leftarrow$ ou le symbole d'égalité $=$. Dans ces notes nous
			utiliserons le symbole d'égalité $=$.

			\begin{langagenaturel}
				variableName = expression
			\end{langagenaturel}

			En Java, nous utiliserons exactement le même symbole $=$~:

			\begin{java}
variableName = <une expression>				
			\end{java}

			Bien que nous utilisions le symbole de l'égalité mathématique, 
			l'assignation n'a pas le même sens. 

			\begin{itemize}
				\item l'égalité mathématique définit que deux choses sont égales 
					et le resteront~;
				\item l'assignation assigne une valeur -- le membre de droite -- 
					à la variable se trouvant à gauche à un moment $t$.
			\end{itemize}
				
			\marginicon{definition}
			Une \textbf{expression}\index{expression} est un calcul faisant
			intervenir des variables, des valeurs explicites et des opérateurs
			(comme +, -, <\dots).  Une expression a une \textbf{valeur}.
					
			\paragraph{Exemples.}
			%------------------------------------------------
				
				Quelques assignations correctes en algorithmique~:
				
				\begin{langagenaturel}
					 denRes = den1 * den2\\
					 count = count + 1\\
					 average = (number1 + number2) / 2\\
					 isALowerthanB = a < b \\
					 aString = "hello"\\
				\end{langagenaturel}

				Et ces même exemples — corrects — en Java~:

				\begin{java}
denRes = den1 * den2;
count = count + 1;
average = (number1 + number2) /2;
isALowerthanB = a < b;
aString = "hello";
				\end{java}
				
			\paragraph{Remarques}
			%------------------------
			
				\begin{itemize}
				\item 
					\textbf{Une assignation n’est ni une égalité, 
					ni une définition}.
					
					Ainsi, l’assignation \pc{cpt \Gets cpt + 1} ne veut pas dire
					que $\textrm{cpt}$ et $\textrm{cpt} + 1$ sont égaux, ce qui
					est mathématiquement faux mais que la \emph{nouvelle} valeur
					de \pc{cpt} doit être calculée en ajoutant 1 à sa valeur
					actuelle.  
					
					Ce calcul doit être effectué au moment de l'exécution
					de cette instruction. 
				
				\item 
					Seules les variables déclarées peuvent être affectées.
				\item 
					Toutes les variables apparaissant dans une expression
					doivent avoir été affectées préalablement. 
					Le contraire provoquerait une erreur,
					un arrêt de l’algorithme ou du programme.
				\item 
					La valeur affectée à une variable 
					doit être compatible avec son type.
					Pas question de mettre une chaine dans une variable
					booléenne.
				\item 
					Certaines personnes utilisent \textbf{$\leftarrow$} comme 
					symbole d'assignation pour les algorithmes. C'est très bien 
					aussi. 

					Nous utiliserons dans ce cours le symbole $=$ afin d'être plus
					proche du langage Java. 
				\end{itemize}
				
				\subsection{Tracer un algorithme}\label{tracer}
		%--------------------------------
		
			Pour vérifier qu’un algorithme est correct, le développeur ou la
			développeuse sera souvent amenée\footnote{Je m'autorise un accord de
			proximité.} à le tracer\index{tracer}.

			\textbf{Tracer} un algorithme ou un programme consiste à suivre
			l’évolution des variables à chaque étape ou à chaque instruction
			et à vérifier qu’elles contiennent bien à tout moment la valeur
			attendue.

			Dans le cadre de nos algorithmes, ce traçage se fait sur papier
			comme dans les exemples ci-dessous. Par contre dans la panoplie des
			outils de développement liés à un langage de programmation apparait
			toujours un débogueur. Un débogueur\index{débogueur} est un outil
			aidant le ou la développeur·se à trouver ses erreurs. La première
			manière de faire étant de tracer son code. Il est donc tout à fait
			possible d'exécuter un programme instruction par instruction et de
			voir le contenu des variables à chaque étape. Nous ne pouvons que
			vous encourager à le faire. 
			
			\paragraph{Exemple.} Traçons des extraits d’algorithmes.
			
			\begin{minipage}{4cm}
				\begin{java}
int a, b et c;
a = 12;
b = 5;
c = a - b;
a = a + c;
b = a;
				\end{java}
			\end{minipage}
			\quad%
			\begin{minipage}{6cm}
			\begin{tabular}{|>{\centering\arraybackslash}m{1cm}
				|*{3}{>{\centering\arraybackslash}m{2cm}}|}
				\hline
				\rowcolor{black!20}
				\verb_#_ & {a} & {b} & {c}\\
				\hline
				1 & {indéfini}             & {indéfini}             & {indéfini}             \\
				2 & {12}                   & {\color{gray}$\mid$}   & {\color{gray}$\mid$}   \\
				3 & {\color{gray}$\mid$}   & {5}                    & {\color{gray}$\mid$}   \\
				4 & {\color{gray}$\mid$}   & {\color{gray}$\mid$}   & {7}                    \\
				5 & {19}                   & {\color{gray}$\mid$}   & {\color{gray}$\mid$}   \\
				6 & {\color{gray}$\mid$}   & {19}                   & {\color{gray}$\mid$}   \\
				\hline
			\end{tabular}
			\end{minipage}

			\bigskip
			\begin{minipage}{4cm}
				\begin{java}
int a, b, c;
a = 12;
c = a - b;
d = c - 2;
			\end{java}
			\end{minipage}
			\quad%
			\begin{minipage}{6cm}
			\begin{tabular}{|>{\centering\arraybackslash}m{1cm}
				|*{3}{>{\centering\arraybackslash}m{2cm}}|}
				\hline
				\rowcolor{black!20}
				\verb_#_ & {a} & {b} & {c}\\
				\hline
				1 & {indéfini}             & {indéfini}             & {indéfini}             \\
				2 & {12}                   & {\color{gray}$\mid$}   & {\color{gray}$\mid$}   \\
				3 & {\color{gray}$\mid$}   & {\color{gray}$\mid$}   & ???                    \\
				4 & {\color{gray}$\mid$}   & {\color{gray}$\mid$}   & ???                    \\
				\hline
			\end{tabular}
			\end{minipage}
			
			\pc{c} ne peut pas être calculé car \pc{b} n’a pas été initialisé;
			quant à \pc{d}, il n’est même pas déclaré~!


		%---------------------------------------------
		\subsection{Exercice résolu~: durée du trajet}
		%---------------------------------------------
					
			Savoir, face à un cas concret, s’il est préférable 
			de décomposer le calcul ou pas, n’est pas toujours évident.	
			La section \vref{lisibilite}
			sur la lisibilité vous apportera des arguments
			qui permettront de trancher.

			L'exercice suivant est suffisamment complexe pour mériter une 
			décomposition du calcul. 

			\begin{Emphase}
				\paragraph{Exercice~: Durée du trajet}
				\label{algo:durée}
				Étant donné la vitesse moyenne non nulle en \textbf{m/s} d’un
				véhicule et la distance parcourue en \textbf{km} par ce
				véhicule, calculer la durée en secondes du trajet de ce
				véhicule.
			\end{Emphase}

			Nous vous proposons de rédiger une solution complète.
			
			Vous pouvez vérifier ensuite sur la fiche \vref{fiche:calcul-complexe}
			qui présente une solution.
				

	%=============================================
	\section{Quelques difficultés liées au calcul}
	%=============================================
	
		Vous êtes habitués à effectuer des calculs.  L’expérience nous montre
		toutefois que certains calculs posent des difficultés.  Soit parce
		que ce sont des opérations peu utilisées, soit parce qu'elles ne sont habituellement pas sous la forme de calculs.  Citons~:

		\begin{itemize}
		\item
			assigner des valeurs booléennes 
			en fonction de comparaisons~;
		\item
			manipuler les opérateurs logiques~;
		\item
			utiliser la division entière et le reste.
		\end{itemize}
		
		Parfois, le problème se situe au niveau de la compréhension du
		vocabulaire.  Examinons ces situations une à une en fournissant des
		exemples et des exercices pour que cela devienne naturel.

		%------------------------------------------------------------------------
		\subsection{Un peu de vocabulaire}
		%------------------------------------------------------------------------

			Quelques notions~: Qu’est-ce qu'un
			opérateur~? Un opérande~?  Rappelons et fixons ces notions.
			
			\marginicon{definition}
			\begin{description}
			\item[expression]\index{expression}
				Une expression indique un calcul à effectuer
				(par exemple~: (a + b) * c).
				Une fois le calcul effectué
				(on dit qu’on \emph{évalue} l’expression), 
				on obtient une valeur, d’un certain type.
				Une expression est composée d’opérandes et d’opérateurs,
				elle a une valeur et un type.
			\item[opérateur]\index{opérateur}
				Un opérateur est ce qui désigne une opération.
				Exemple~: \Verb_+_ désigne l’addition.
			\item[opérande]\index{opérande}
				Un opérande est ce sur quoi porte l’opération.
				Exemple~: dans l’expression \Verb_a+b_, 
				\Verb_a_ et \Verb_b_ sont les opérandes.
				Un opérande peut être une sous-expression.
				Exemple~: dans l’expression \Verb_(a+b) * c_, 
				\Verb_(a+b)_ est l’opérande 
				de gauche de l’opérateur \Verb_*_ et \Verb_c_ l'opérande de 
				droite.
			\item[unaire, binaire, ternaire]\index{unaire}\index{binaire}\index{ternaire}
				Un opérateur qui agit sur deux opérandes (le plus fréquent)
				est qualifié de binaire. 
				On rencontre aussi des opérateurs unaires (ex: le \Verb_-_ 
				dans l’expression \Verb_-a_).
				En Java, vous rencontrerez aussi un opérateur ternaire (3 opérandes)
				mais ils sont plus rares.
			\item[littéral]\index{littéral}
				Un littéral est une valeur notée explicitement 
				(comme \Verb_12_, \Verb_34.4_, \Verb_"bonjour"_)
			\item[priorité]\index{priorité}

				Les opérateurs sont classés par priorité.  Cela permet de savoir
				dans quel ordre les exécuter.  Par exemple, la multiplication
				est prioritaire par rapport à l'addition.  C’est pourquoi
				l'expression \Verb_a + b * c_ est équivalente à 
				\Verb_a + (b * c)_ et pas à \Verb_(a + b) * c_.  
				Les parenthèses permettent
				de modifier ou de souligner la priorité.  
		
		\end{description}
			
			\begin{Emphase}
				\paragraph{Exercice~: analyse d’expression}
				
				Voici une série d’expressions. Nous vous proposons d’identifier
				tous les opérateurs et leurs opérandes, d’indiquer si les
				opérateurs sont unaires ou binaires et d’identifier les
				littéraux.  
				
				Nous vous proposons aussi de fournir une version de
				l’expression avec le moins de parenthèses possibles et une autre
				avec un maximum de parenthèses (tout en respectant le sens de
				l’expression bien sûr et sans mettre de parenthèses redondantes).
				
				\begin{itemize}
				\item \Verb_a+1_
				\item \Verb_(a+b)*12-4*(-a-b)_ 
				\item \Verb_a+(b*12)-4*-a_ 
				\end{itemize}
			\end{Emphase}
		

		%------------------------------------------------------------------------
		\subsection{Les comparaisons et les assignations de variables booléennes}
		%------------------------------------------------------------------------
		\index{comparaisons}
		
			$3+1$ est un calcul dont le résultat est $4$, un entier. C'est sans
			doute évident.
			
			$1<3$ est aussi un calcul dont le résultat est un \emph{booléen},
			vrai en l’occurrence.  Ce résultat peut être assigné à une variable
			booléenne.			

			\textbf{Exemples.}
			Voici quelques assignations correctes~:
			
			\begin{java}
boolean positive, 
	adult, 
	successful, 
	perfect;
positive = nb > 0;
adult = age >= 21;
successful = code >= 10;
perfect = errors == 0;
			\end{java}

			\paragraph{Remarque}

			Pour tester l'égalité, nous utilisons le symbole $==$ afin de le 
			différencier du symbole $=$ qui est le symbole de d'assignation. 
		
			\begin{Emphase}
				\paragraph{Exercices~: écrire des expressions booléennes}
				Pour chacune des phrases suivantes,
				écrivez l’assignation qui lui correspond.
				\begin{itemize}
				\item 
					La variable booléenne \pc{négatif}
					doit indiquer si le nombre \pc{montant} est négatif.
				\item
					Un groupe est complet s’il contient exactement 20 personnes.
				\item
					Un algorithme est considéré comme long si le nombre de lignes
					dépasse 20.
				\item 
					Un étudiant a \emph{la plus grande distinction} si sa cote est
					de 18/20 ou plus.
				\end{itemize}
			\end{Emphase}

		%------------------------------------------------------------------------
		\subsection{Les opérations logiques}
		%------------------------------------------------------------------------
		\index{opérateurs logiques}
		\index{NON}\index{ET}\index{OU}
		\index{AND}\index{OR}
	
			Les opérateurs logiques agissent sur des expressions booléennes 
			(variables ou expressions à valeurs booléennes) 
			pour donner un résultat du même type.
	
			\begin{center}
			\begin{tabular}{m{15mm}|m{3cm}|m{8cm}}
			\hline
			\rowcolor{black!20}
			opérateur & nom & description \\
			\hline
			\raggedleft \pc{NON} & négation & vrai devient faux et inversement\\
			\raggedleft \pc{AND} & conjonction logique 
				& vrai si les 2 conditions sont vraies\\
			\raggedleft \pc{OR} & disjonction logique 
				& vrai si au moins une des 2 conditions est vraie\\
			\hline
			\end{tabular}
			\end{center}
			\medskip
			
			\paragraph{Remarque}
			Nous utilisons \pc{AND} et \pc{OR} mais nous acceptons et comprenons 
			\pc{ET} et \pc{OU}. 

			Ce tableau se résume en \emph{tables de vérité}
			\index{tables de vérité} comme suit~:

			
			\begin{center}
			\begin{tabular}{|ccc|}
				\hline
				\rowcolor{black!20}
				a & b & a AND b   \\
				\hline
				true & true & true \\\hline
				true & false & false \\\hline
				false & true & false \\\hline
				false & false & false \\\hline				
			\end{tabular}
			\qquad
			\begin{tabular}{|ccc|}
				\hline
				\rowcolor{black!20}
				a & b  & a OR b \\
				\hline
				true & true & true \\\hline
				true & false & true \\\hline
				false & true & true \\\hline
				false & false & false \\\hline				
			\end{tabular}
			\qquad
			\begin{tabular}{|cc|}
				\hline
				\rowcolor{black!20}
				a & NON a \\
				\hline
				true & false \\\hline
				false & true \\\hline
			\end{tabular}
			\end{center}

			Ces opérateurs peuvent intervenir dans des expressions booléennes.

			\textbf{Exemples}
			
			\begin{small}
			\begin{multicols}{2}
				\begin{itemize}
					\item \pc{tarifPlein \Gets 18$\le$âge ET âge$<$60}
					\item \pc{distinction \Gets 14$\le$cote ET cote<16}
					\item \pc{nbA3chiffres \Gets 100$\le$nb ET nb$\le$999}
					\item \pc{tarifRéduit \Gets NON tarifPlein}
					\item \pc{tarifRéduit \Gets NON (18$\le$âge ET âge$<$60)}
					\item \pc{tarifRéduit \Gets âge$<$18 OU 60$\le$âge}
				\end{itemize}
			\end{multicols}
			\end{small}

			En Java, le \pc{AND} (ET) s'écrit \pc{\&\&}
			\footnote{\pc{\&} est le caractère \textit{ampersand} (esperluette 
			en français)}
			et le \pc{OR} (OU), \pc{||}
			\footnote{\pc{|} est le caractère \textit{pipe} (barre verticale 
			en français)}.

	
			Écrire des calculs utilisant ces opérateurs n’est pas facile
			car le français nous induit souvent en erreur
			en nous poussant à utiliser un ET pour un OU et inversement
			ou bien à utiliser des raccourcis d’écriture ambigus%
			\footnote{%
				Vous noterez que le nombre de "et" et de "ou"
				dans cette phrase ne facilite pas sa compréhension~;)%
			}. 
			
			Par exemple, ne pas écrire~: 
			\pc{tarifRéduit \Gets âge$<$18 OU $\ge$60}
	
			\paragraph{Loi de De Morgan.}\index{Morgan}
				Cette loi s'énonce: 
				\begin{quote}
					{\LARGE «}
					La négation d'une conjonction (\pc{AND}) de deux
					propositions est la disjonction (\pc{OR}) des deux
					négations. De même, la négation d'une disjonction de deux
					propositions est la conjonction des deux négations.~{\LARGE »}
				\end{quote}

				… et s'écrit plus simplement~:
				\[
					\mathrm{NON}\ (a\ \mathrm{AND}\ b) \Leftrightarrow \mathrm{NON}\ a\ \mathrm{OR}\ \mathrm{NON}\ b
				\]
				\[
					\mathrm{NON}\ (a\ \mathrm{OR}\ b) \Leftrightarrow \mathrm{NON}\ a\ \mathrm{AND}\ \mathrm{NON}\ b
				\]
				
				Par exemple, ces trois propositions sont équivalentes~: 
				
				\begin{center}	
					\large
				\pc{tarifRéduit \Gets NON (18$\le$âge AND âge$<$60)}\\
				\medskip
				\pc{tarifRéduit \Gets (NON 18$\le$âge) OR (NON âge$<$60)}\\
				\medskip
				\pc{tarifRéduit \Gets âge$<$18 OR 60$\le$âge}\\
				\end{center}
	
			\paragraph{Priorités et parenthèses.}
			\index{priorité}

				L'opérateur \pc{NON} est prioritaire sur les opérateurs \pc{AND}
				et \pc{OR}.

				L'opérateur \pc{AND} est prioritaire sur le \pc{OR}.
				
				Ainsi l’expression~: \pc{NON a OR b AND c}
				doit se comprendre~: \pc{(NON a) OR (b AND c)}.
				Il est toujours possible d'ajouter des parenthèse pour aider 
				à la compréhension. 

				\paragraph{Évaluation paresseuse} 
				\index{court-circuit}\label{court-circuit}
			
				L'évaluation paresseuse (\textit{lazy evaluation}) ou évaluation
				court-circuitée est une évaluation qui s'arrête dès que le 
				résultat est connu. 
			
				Les opérateurs AND et OR sont des opérateurs court-circuités.
				En particulier, si la première partie d’un AND est fausse, il
				n'est pas nécessaire de regarder le deuxième opérande; le
				résultat sera faux. De même si la première partie d'un OR est
				vraie; le résultat sera vrai quelle que soit la valeur de la
				deuxième partie. 

				Cette manière de fonctionner permet de gagner du temps dans
				l'évaluation et permet aussi d'éviter des erreurs. Ceci est vrai
				dans les algorithmes et — surtout — dans beaucoup de langages 
				de programmation. Java utilise cette évaluation paresseuse.  
				 
				\textbf{Exemples.}

				\begin{java}
boolean ok;

// Génère une erreur si b est nul
ok = 1/b < 0.1;

// Si b est nul, provoque une erreur et un arrêt
ok = 1/b < 0.1 && b != 0;

// YES ! C'est dans le bon ordre si b est nul, 
// la condition est fausse et
// ok reçoit false
ok = b != 0 && 1/b < 0.1;
				\end{java}

				Cette propriété sera abondamment utilisée dans le parcours
				de tableaux par exemple. 

				
				\begin{Emphase}
				\paragraph{Exercice: simplifier des expressions booléennes}

				Voici quelques assignations correctes du point de vue de la
				syntaxe mais contenant des lourdeurs d’écriture.  Trouvez des
				expressions plus simples qui auront un effet équivalent.
				
				\begin{itemize}
					\item \pc{beautifulBoolean \Gets adulte == vrai}
					\item \pc{beautifulBoolean \Gets adulte == faux}
					\item \pc{beautifulBoolean \Gets etudiant == vrai 
						AND jeune == faux}
					\item \pc{beautifulBoolean \Gets NON (adulte == vrai) 
						AND NON (adulte == faux)}
					\item \pc{nbA3chiffres \Gets NON (nb$<$100 OR nb$\ge$1000)}
				\end{itemize}		
			\end{Emphase}
		
			\begin{Emphase}
				\paragraph{Exercice: expressions logiques}
				Pour chacune des phrases suivantes,
				écrivez l’assignation qui lui correspond.
				\begin{itemize}
				\item J’irai au cinéma si le film me plait et que 
					j’ai 20\texteuro{} en poche.
				\item Je n’irai pas au cinéma si je n’ai pas 
					20\texteuro{} en poche.
				\item Je brosserai le premier cours de la journée 
					s’il commence à 8h et aussi si je n’ai pas dormi mes 8h.
				\end{itemize}
			\end{Emphase}
			
		%-------------------------------------------
		\subsection{La division entière et le reste}
		%-------------------------------------------
		\index{DIV}\index{MOD}
		\index{division entière}
		\index{modulo}
		
			\marginicon{definition}
			La \textbf{division entière} consiste à effectuer une division
			en ne gardant que la partie entière du résultat.
			Le \textbf{reste} de la division entière de a par b
			est ce qui n’a pas été repris dans la division… ce qu'il reste. 
			
			Lorsque l'on fait une division entière, le
			\textbf{dividende} \pc{D} est divisé par le \textbf{diviseur} \pc{d}
			pour donner un \textbf{quotient} \pc{q} et, éventuellement, un
			\textbf{reste} \pc{r}.

			\[
				D = d * q + r 
			\]\[
				\frac{D}{d} = q 
			\]
			\begin{flushright}
				et, éventuellement un reste  $r$				
			\end{flushright}
				
			La division entière est souvent notée \pc{DIV} et le
			reste \pc{MOD}. 
			
			\begin{itemize}
				\item $a$ \pc{DIV} $b$ est le quotient de la division et
				\item $a$ \pc{MOD} $b$ — nous dirons \textit{a modulo b} — 
					est le reste de cette division.  
			\end{itemize}

			En Java, la division se note $/$ et le reste $\%$.
			
			Par exemple, imaginons qu’une classe comprenne 14 étudiants et
			étudiantes qu’il faut réunir par 3 dans le cadre d’un travail de
			groupe.  Il est possible de former 4 groupes mais il restera
			2 étudiants et étudiantes ne pouvant former un groupe complet.
			C’est le reste de la division de 14 par 3.
			
			\textbf{Exemples}~:	
			
			\begin{minipage}{9cm}
			\begin{multicols}{2}
			\begin{itemize}
				\item 7 DIV 2 vaut 3
				\item 8 DIV 2 vaut 4
				\item 6 DIV 6 vaut 1
				\item 6 DIV 7 vaut 0
				\item 7 MOD 2 vaut 1
				\item 8 MOD 2 vaut 0
				\item 6 MOD 6 vaut 0
				\item 6 MOD 7 vaut 6
			\end{itemize}
			\end{multicols}
			\end{minipage}

			
			
		\subsubsection{Utilité - Tester la divisibilité}
		%-------------------------------------
		
			Les deux opérateurs \pc{MOD} et \pc{DIV}, respectivement \pc{/} et
			\pc{\%}, permettent, par exemple, de tester si un nombre est un
			multiple d’un autre.

			Si l'on veut savoir si un nombre est \textbf{pair}
			— pour rappel, un nombre pair est un multiple de 2 — il suffit 
			de vérifier que le reste de la division par 2 est nul.
			
			\[
			\textrm{nb pair} 
				\quad\equiv\quad \textrm{nb divisible par 2} 
				\quad\equiv\quad \textrm{nb MOD 2 = 0} 
			\]
			
			En supposant que \pc{isOdd} (\textit{odd} pour pair et \textit{even}
			pour impair) est une varibale booléenne, nous pourrions donc
			écrire~: \pc{isOdd \Gets nb MOD 2 == 0}.

			Et, en langage java~:

			\begin{java}
boolean isOdd;
isOdd = nb % 2 == 0;
			\end{java}

		\subsubsection{Utilité - Extraire les chiffres d’un nombre}
		%------------------------------------------------
		
			Faisons une petite expérience numérique.
			\begin{center}
			\begin{tabular}{|l|r|}\hline
				\rowcolor{black!20}
				calcul & résultat \\
				\hline
				65536 MOD 10 & 6 \\  
				65536 MOD 100 & 36 \\  
				65536 MOD 1000 & 536 \\  
				65536 MOD 10000 & 5536 \\ 
				\hline 
			\end{tabular}
			\qquad
			\begin{tabular}{|l|l|}\hline
				\rowcolor{black!20}
				calcul & résultat \\
				\hline
				65536 DIV 10 & 6553 \\  
				65536 DIV 100 & 655 \\  
				65536 DIV 1000 & 65 \\  
				65536 DIV 10000 & 6 \\ 
				\hline 
			\end{tabular}
			\end{center}
		
			Nous voyons que les divisions entières (\pc{DIV}) et les restes
			(\pc{MOD}) avec des puissances de 10 permettent de conserver les
			chiffres de droite (division entière, MOD) ou d'enlever les chiffres
			de droite (DIV).  Combinés, ils permettent d’extraire n’importe quel
			chiffre d’un nombre.
			
			\textbf{Exemple}~: (65536 DIV 100) MOD 10 = 5… qui est le chiffre des
			centaines. 


		
		%---------------------
		\subsection{Le hasard et les nombres aléatoires}
		\label{hasard}\index{hasard}\index{aléatoire}
		%---------------------
			
			Il existe de nombreuses applications qui font intervenir le hasard.
		
			Par exemple dans les jeux où il est nécessaire de mélanger des
			cartes, lancer des dés, faire apparaitre des ennemis de façon
			aléatoire\dots
			
			Le vrai hasard n’existe pas en informatique
			puisqu’il s’agit de suivre des étapes précises
			dans un ordre fixé et que la machine est déterministe. 
			Pourtant, on peut concevoir des algorithmes et des programmes 
			qui \emph{simulent} le hasard%
			\footnote{%
				Pour être précis, nous devrions dire pseudo-hasard
				ou algorithmes et programmes pseudo-aléatoires.
			}.
			À partir d’un nombre donné%
			\footnote{%
				Ce nombre peut être fixé ou généré à partir
				de l’environnement 
				(par exemple, l’horloge interne).
			}
			(appelé \emph{graine} ou \emph{seed} en anglais)
			ils fournissent une suite de nombres qui \emph{ont l’air}
			aléatoires.			

			Concevoir de tels algorithmes est très compliqué et dépasse
			largement le cadre de ce cours.  Heureusement, la plupart des
			langages informatiques proposent de base une façon d'obtenir un tel
			nombre aléatoire.

			En Java, il suffit d'écrire
			\footnote{Nous verrons plus tard qu'il existe une autre manière 
				de faire en utilisant la classe \pc{Random}}

			\begin{java}
double number = Math.random();				
			\end{java}

			pour obtenir un nombre (pseudo-)aléatoire compris entre 0 et 1 
			strictement. C'est-à-dire strictement plus petit que 1. 

			Dans nos algorithmes, nous pouvons toujours supposer qu'il existe un
			tel algorithme sans devoir l'écrire. 

			\begin{center}
				\flowalgor{random}{réel (entre 0 inclus et 1 exclu)}
			\end{center}
			
			À partir de cet algorithme et de cette méthode découlent ces deux
			autres «~algorithmes~»:

			\begin{itemize}
				\item un entier entre 0 inclus et n exclu

					\begin{langagenaturel}
						(la partie entière de) random() * n
					\end{langagenaturel}

				\item un entier entre min et max inclus

					\begin{langagenaturel}
						(la partie entière de) min + random() * (max-min+1)
					\end{langagenaturel}
			
			\end{itemize}

			En langage Java, il existe une méthode \verb_Math.random()_ comme
			nous l'avons dit mais également une autre manière de faire en
			utilisant la classe \textbf{Random} comme ceci\footnote{Le code
			n'est pas fonctionnel en l'état. Il manque un \textit{import}.
			Nous y reviendrons}~: 

			\begin{java}
Random R = new Random();

// Une valeur entière comprise entre 0 et 13 strictement
int value = R.nextInt(13);

// Une valeur entière comprise entre 10 et 20 strictement
int value2 = 10 + R.nextInt(10);

// Une valeur pseudo-réelle entre 0 et 1 strictement
double value3 = R.nextDouble();
			\end{java}
			

	%======================================================================
	\section{Des algorithmes et des programmes de qualité}
	%======================================================================
	
		Dans la section précédente,
		nous avons vu qu’il est possible de décomposer un calcul en étapes.
		Mais quand faut-il le faire~?	
		Ou, pour poser la question autrement~:
		
			\begin{quote}
				\textbf{Puisqu’il existe plusieurs algorithmes 
				qui résolvent un problème, lequel préférer~? Quelle traduction 
				dans un langage de programmation (Java) privilégier~?}
			\end{quote}
		
		Répondre à cette question, c’est se demander ce qui fait la qualité d’un
		algorithme ou d’un programme informatique.  Quels sont les critères qui
		permettent de juger~?
		
		C’est un vaste sujet mais nous voudrions aborder les principaux.

		La connaissance de l'algorithmique permet d'écrire des algorithmes de 
		qualité. La connaissance d'un langage — qui est une autre compétence —
		permet d'écrire des programmes de qualité. Les qualités de l'un n'étant 
		pas nécessairement celles de l'autre. 
		
		%------------------------------------------
		\subsection{L’efficacité}\index{efficacité}
		%------------------------------------------
			
			L’\textbf{efficacité}
			\footnote{%
				À ne pas confondre avec \emph{l’efficience}
				qui indique qu’il est économe en ressources.
			}
			désigne le fait que l’algorithme (le programme) résout%
			bien le problème donné.
			C’est un minimum~!
		
		%-------------------------------------------
		\subsection{La lisibilité}\index{lisibilité}
		%-------------------------------------------
		
			La \textbf{lisibilité} indique si une personne qui lit l’algorithme
			ou le programme peut facilement percevoir comment il fonctionne.
			C’est crucial car un algorithme ou un programme est \textbf{souvent
			lu} par de nombreuses personnes~:
			
			\begin{itemize}
			\item
				celles qui doivent se convaincre de sa validité
				avant de passer à la programmation~;
			\item
				celles qui doivent trouver les causes
				d’une erreur lorsque celle-ci a été rencontrée%
				\footnote{%
					On parle du processus de \emph{déverminage}
					(ou \emph{debugging} en anglais).%
				}~;
			\item
				celles qui doivent faire évoluer l’algorithme
				ou le programme suite à une modification
				du problème~;
			\item
				et, accessoirement, celles qui doivent le coter~;)
			\end{itemize}
			
			C’est un critère \textbf{très important} qu’il ne faut surtout pas
			sous-évaluer.  Vous en ferez d’ailleurs l’amère expérience~: si vous
			négligez la lisibilité de votre algorithme ou de votre programme,
			vous-même ne le comprendrez plus quand vous le relirez quelque temps
			plus tard~!
			
			Comparer la lisibilité de deux algorithmes ou de deux programmes
			n’est pas une tâche évidente car c’est une notion subjective.  Il
			faut se demander quelle version va être le plus facilement comprise
			par la majorité des lecteurs. La section \vref{lisibilite}
			explique ce qui peut être fait pour rendre ses algorithmes plus
			lisibles. À ces recommandations s'ajouteront les \textbf{conventions
			d'écriture} propres à chaque langage qu'il faudra aussi respecter. 
				
		%---------------------------------------	
		\subsection{La rapidité}\index{rapidité}
	    %---------------------------------------
	    
			%{\Huge\bf TODO}
			
			La \textbf{rapidité} indique si l’algorithme ou le programme permet
			d’arriver plus ou moins vite au résultat.
			
			C’est un critère qui est souvent sur-évalué, 
			essentiellement pour deux raisons.
			\begin{itemize}
				\item 
					Il est trompeur. 
					On peut croire une version plus rapide alors qu’il n’en est rien.
					Par exemple, on peut se dire que décomposer un calcul
					ralentit un programme puisqu’il doit gérer des variables
					intermédiaires.
					Ce n’est pas forcément le cas.
					Les compilateurs modernes sont capables
					de nombreuses prouesses pour optimiser le code
					et fournir un résultat aussi rapide
					qu’avec un calcul non décomposé.
				\item
					L’expérience montre que la recherche de rapidité
					mène souvent à des algorithmes moins lisibles.
					Or la lisibilité doit être privilégiée à la rapidité
					car sinon il sera impossible de corriger et/ou
					de faire évoluer l’algorithme.
			\end{itemize}
		
			Ce critère est un cas particulier de l’\emph{efficience} qui traite
			de la gestion économe des ressources.  Nous reparlerons de rapidité
			dans le chapitre consacré à la \emph{complexité} des algorithmes.

			Le langage Java est réputé lent. C'est une affirmation péremptoire
			et peut-être périmée. Bien sûr, comme le \textit{bytecode} est
			interprèté (ces notions sont expliquées dans la section 
			\ref{compilation-interprètation} 
			p.~\pageref{compilation-interprètation})
			, il est nécessaire de charger la machine virtuelle. La
			gestion de la mémoire prise en charge par le langage a aussi un
			certain cout. Hormis ces deux aspects, la rapidité d'un programme
			dépend surtout de la qualité du code… et donc du développeur.  

			L'important, dans ce premier cours de développement est d'écrire des 
			programmes lisibles et  respectant les conventions d'écriture. 
			
		%---------------------	
		\subsection{La taille}
		%---------------------
		
			Nous voyons parfois des étudiants et des étudiantes contentes
			d’avoir pu écrire un algorithme en moins de lignes.  Ce critère n’a
			\textbf{aucune importance}~; un algorithme plus court n’est pas
			nécessairement plus rapide ni plus lisible.

			Lors de la traduction en langage Java, certaines formes d'écriture
			— plus courtes — seront privilégiées. Nous y reviendrons et -- au fur
			et à mesure de l'apprentissage -- elles deviendront vite évidentes.
		
		%----------------------		
		\subsection{Conclusion}
		%----------------------		
			
			Tous ces critères n’ont pas le même poids.  Le point le plus
			important est bien sûr d’écrire des algorithmes et des programmes
			corrects mais ne vous arrêtez pas là~!  Demandez-vous s’il n’est pas
			possible de le retravailler pour améliorer sa lisibilité%
			\footnote{%
				On appelle \emph{refactorisation} l’opération qui consiste
				à modifier un algorithme ou un code sans changer ce qu’il fait
				dans le but, notamment, de le rendre plus lisible.
			}.
		
	%============================================
	\section{Améliorer la lisibilité}
	\label{lisibilite}\index{lisibilité}
	%============================================
		
		Comme nous venons de le voir, la lisibilité est une qualité essentielle
		que doivent avoir nos algorithmes et nos programmes.  Qu’est ce qui
		permet d’améliorer la lisibilité d’un algorithme~?

		\subsection{Mise en page des algorithmes et des programmes} 
		
			Il y a d’abord la \textbf{mise en page} qui aide le lecteur à avoir
			une meilleure vue d’ensemble de l’algorithme, à en repérer
			rapidement la structure générale.  Ainsi, dans ce syllabus~:

			\begin{itemize}
			\item 
				les mots imposés ou, tout au moins importants, 
				\index{mots-clés}
				sont mis en évidence (en gras%
				\footnote{%
					Difficile de mettre en gras avec un bic.
					Dans une version écrite vous pouvez~:
					souligner ou surligner le mot, l’écrire en majuscule
					ou le mettre en couleur.%
				})~;
			\item
				une seule instruction se trouve par ligne~;
			\item
				les instructions à l’intérieur de l’algorithme sont 
				\emph{indentées}\index{indentation}
				(décalées vers la droite).
				On indentera également les instructions
				à l’intérieur des choix et des boucles~;
			\item

				Le début et la fin de quelque chose — un bloc — sont marqués 
				par des accolades ({}) ou une ligne. 
			\end{itemize}
			
			\textbf{Exemples}

			On n'écrira pas~:

			\marginicon{dont}
			\begin{java}
public static double travelTime(double speedMS, double distanceKm) {
double distanceM;
distance M = 1000 * distanceKM;
return distanceM / speedMS;
}
			\end{java}

			ni~:
			
			\marginicon{dont}
			\begin{java}
public static double travelTime(double speedMS, double distanceKm) {
	double distanceM;
		distance M = 1000 * distanceKM; return distanceM / speedMS; }
			\end{java}

			mais plutôt~:

			\begin{java}
public static double travelTime(double speedMS, double distanceKm) {
	double distanceM;
	distance M = 1000 * distanceKM;
	return distanceM / speedMS;
}
			\end{java}

			\medskip
	
			Plus spécifiquement pour les programmes, l'utilisation d'un éditeur 
			de code% 
			\footnote{%
				Un éditeur de code est un programme aidant à l'édition de code
				qu'il ne faut pas confondre avec un éditeur de texte. Des
				éditeurs de codes connus; \textit{gVim}, \textit{Notepad++}
			} ou d'un IDE (Environnement de Développement Intégré)%
			\footnote{
				Des IDE connus; \textit{Netbeans}, \textit{Eclipse}…
			}
			aide à l'écriture de programmes lisibles et respectant les
			conventions. 
		
			\begin{itemize}
				\item Le code est indenté comme les algorithmes.
				\item Une seule instruction par ligne.
				\item La longueur des lignes n'excède pas 80 caractères%
					\footnote{
						Ce n'est pas la largeur de l'écran qui détermine la 
						longueur des lignes. La limite à 80 caractères permet 
						un code plus lisible. Elle permet aussi de pouvoir lire
						plus vite le code en limitant le mouvement des yeux de 
						gauche à droite. 
					}.
				\item S'il est nécessaire de couper une ligne trop longue, 
					celle-ci est coupée avant un opérateur ou après une virgule.
			\end{itemize}

			\begin{java}
public static boolean iDoNothing(double beautifulDouble, 
		int firstInteger, boolean isItReallyTrue){
	double notSoBeautiful = beautifulDouble * firstInteger; 
	return notSoBeautiful > 100 && notSoBeautiful < 10000
		|| isItReallyTrue;
}
			\end{java}


		\subsection{Choix des noms}
			
			Il y a, ensuite, l’écriture des instructions elles-mêmes.
			Ainsi~:
			\begin{itemize}
			\item
				Il faut choisir soigneusement les noms 
				(d’algorithmes, de paramètres, de variables\dots)
			\item
				Il faut décomposer (ou au contraire fusionner)
				des calculs pour arriver au résultat jugé
				le plus lisible.
			\item 
				Il est également possible d'introduire des commentaires et/ou
				des constantes. Deux concepts que nous allons développer 
				maintenant.
			\end{itemize}
			
				
		%------------------------------------------------
		\subsection{Les commentaires}\index{commentaires}
		%------------------------------------------------
	
			\marginicon{definition}
			\textbf{Commenter} un algorithme
			signifie lui ajouter du texte explicatif
			destiné au \textbf{lecteur} pour l’aider à mieux
			comprendre le fonctionnement de l’algorithme.
			Un commentaire n’est pas utilisé par celui qui exécute
			l’algorithme; il ne modifie pas ce que l’algorithme fait.
			
			Habituellement, on distingue deux sortes de commentaires~:
			\begin{itemize}
			\item
				Ceux placés \textbf{au-dessus} de l’algorithme ou du programme
				qui expliquent \textbf{ce qu'il fait} 
				et dans quelles \textbf{conditions} il fonctionne
				(les contraintes sur les paramètres).
				\par C'est la documentation \textbf{documentation}.
			\item
				Ceux placés \textbf{dans} l’algorithme ou le programme
				qui expliquent \textbf{comment} il le fait.
			\end{itemize}
			
			Commenter correctement un programme est une tâche qui n’est pas
			évidente et qu’il faut travailler.  Il faut arriver à apporter au
			lecteur une information \textbf{utile} qui n’apparait pas
			directement dans le code.  Par exemple, il est contre-productif de
			répéter ce que l’instruction dit déjà. Il faut supposer que le 
			lecteur connait le langage et l'algorithmique.   

			Dans nos algorithmes, les commentaires commencent par \pc{//}. 

			En langage Java, il y a trois manières de commenter~:

			\begin{enumerate}
				\item \pc{//} en début de ligne;
				\item le commentaire sur plusieurs lignes en commençant par 
					\pc{/*} et en le terminant par \pc{*/};
					
					\pc{/* <commentaire> */} 

				\item le commentaire sur plusieurs lignes en commençant par 
					\pc{/**} et en le terminant par \pc{*/}. Dans ce cas, 
					c'est un commentaire destiné à la documentation 
					\textit{javadoc}. Nous y reviendrons (dans la section
					\ref{chap:javadoc} p.\pageref{chap:javadoc}). 
					\index{javadoc}
			\end{enumerate}
			
			Voici quelques mauvais 	commentaires
			

			\marginicon{dont}
				\begin{java}
double length 		// La longeur est un réel
/* La somme est initialisée à 0. 
   Ce sera toujours le cas. */
int sum = 0;
				\end{java}
		
				\paragraph{Remarque}

				Un excès de commentaires peut être le révélateur des problèmes
				de lisibilité du code lui-même.  Par exemple, un choix judicieux
				de noms de variables peut s’avérer bien plus efficace que des
				commentaires.  Ainsi, écrire~:

				\begin{langagenaturel}
					newCapital = oldCapital * ( 1 + rate / 100 )
				\end{langagenaturel}

	
				sans commentaires est bien préférable aux lignes suivantes~:
	
				\begin{wrong}
					\begin{langagenaturel}
						c1 = c0 * ( 1 + r/100)
						
						Calcul du nouveau capital en appliqant le taux
					\end{langagenaturel}
				\end{wrong}

			\bigskip
			Pour résumer~:
			\begin{quote}
				\bfseries
				N’hésitez pas à documenter votre programme 
				pour expliquer ce qu’il fait
				et à le retravailler pour que tout
				commentaire à l’intérieur de l’algorithme
				devienne superflu.
			\end{quote}

			\paragraph{Exemples.}
			Voici comment on pourrait documenter un de nos algorithmes.

			\begin{java}
/* 
 * Calcule la surface d'un rectangle dont on donne la largeur et 
 * la longueur.
 * 
 * Les données ne sont pas négatives.
 */
public static double rectangleArea (double length, double width){
	return length * width;
}
			\end{java}
			
		%--------------------------------------------
		\subsection{Constantes}\index{constantes}
		%--------------------------------------------
	
			Une \textbf{constante} est une information pour laquelle nom, type
			et valeur sont figés. 

			L'usage est d'écrire les constantes en majuscules. 
			
			L’utilisation de constantes dans vos algorithmes présente
			les avantages suivants~:
			\begin{itemize}
			\item
				une meilleure lisibilité du code,
				pour autant que vous lui trouviez un nom explicite~;
			\item
				une plus grande facilité pour modifier le code
				si la constante vient à changer 
				(modification légale du seuil de réussite par exemple).
			\end{itemize}
			
			\textbf{Exemples}
			
			\begin{java}
public static final double PI = 3.1415;
public static final int PASS_LEVEL = 10;
public static final String ESI = "École supérieure d'Informatique";
			\end{java}

			\paragraph{Remarque}

			En Java, définir une constante $\pi$ est un mauvais choix. Cette 
			constante existe déjà. Elle est accessible directement 
			par \pc{Math.PI}.

		
			\begin{Emphase}
				\paragraph{Exercice}
				Utiliser une constante.
				Trouvez un algorithme que vous avez écrit
				où l’utilisation de constante
				pourrait améliorer la lisibilité de votre solution.
			\end{Emphase}
			
	%=====================================
	\section{Appel d'algorithme, appel de méthode}
	%=====================================
	
		Reprenons l’algorithme \pc{rectangleArea} qui nous a souvent servi
		d’exemple.  Il permet de calculer la surface d’un rectangle dont on
		connait la longueur et la largeur.  Mais d’où viennent les données~?  Et
		que faire du résultat~?
		
		Tout d’abord, un algorithme ou un programme peut utiliser 
		(on dit \textbf{appeler}\index{appel}) un autre algorithme ou programme.
	
		Cet autre algorithme doit exister \emph{quelque part}~: sur la même
		page, une autre page, un autre document, peu importe.
		
		En Java, la contrainte est un peu plus forte.  Les programmes sont
		généralement écrits dans plusieurs fichiers qui doivent «~se
		retrouver~»… mais dans un premier temps, nous nous contenterons d'un
		seul.  Ce fichier représentera une \emph{classe}\index{classe}. 

		\begin{itemize}
			\item Les instructions qui définissent une classe sont:
				\begin{java}
public class MyClass{
	// statements
}
				\end{java}
			\item La classe \pc{MyClass} doit se trouver dans le fichier 
				\texttt{MyClass.java}\footnote{Cette contrainte peut être 
					relâchée à partir de JDK11. Voir 
					\url{http://namok.be/blog/?post/2019/04/06/JDK10-11-12}}
		\end{itemize}

		Pour pouvoir appeler une méthode en Java qui se trouve dans la même 
		classe, il suffit d'écrire~:
		
		\begin{java}
area = rectangleArea(122, 3.78);			
		\end{java}
		
		L’appel d’une méthode est considéré comme une expression, un calcul qui,
		comme toute expression, possède une valeur (la valeur retournée) et un
		type. Elle peut intervenir dans un calcul plus grand, être assignée
		à une variable\dots
	
	%=====================================
	\section{Interagir avec l'utilisateur}
	%=====================================
		%-----------------------------------------
		\subsection{Afficher un résultat}\index{afficher}
		%-----------------------------------------
		
			Un programme concret (en Java par exemple) qui permet de calculer
			des surfaces de rectangles devra communiquer le résultat
			à l’utilisateur du programme.  Nous allons renseigner un affichage
			par la commande \pc{\K{print}}.  Ce qui donne~:
			
			\begin{langagenaturel}
				print 2\\
				print rectangleArea(122, 3.78)\\

				afficher 3
			\end{langagenaturel}

			En langage naturel, nous pouvons choisir d'écrire afficher, print,
			écrire à l'écran… Dans ces notes, nous écrirons \pc{\K{print}}.
	
			L’instruction \pc{\K{print}} signifie que l’algorithme doit, à cet
			endroit communiquer une information à l’utilisateur.
			La façon dont il va communiquer cette information (à l’écran dans
			une application texte, via une application graphique, sur un cadran
			de calculatrice ou de montre, sur une feuille de papier imprimée,
			via un synthétiseur vocal\dots) ne nous intéresse pas ici.

			En langage Java, un affichage sur la \emph{sortie standard}, la 
			console ou encore dans le terminal se fait comme suit~:

			\begin{java}
System.out.println(rectangleArea(122, 3.78);				
			\end{java}

			Les lettres \textit{ln} qui suivent le mot \textit{print} signifient
			\textit{new line} et indiquent un passage à la ligne après
			l'affichage. Il existe aussi une instruction \pc{print} sans les
			lettres \textit{ln}… qui ne passe pas à la ligne. 
		
			Avec un organigramme, les affichages et les demandes peuvent 
			se faire à l'aide d'un parallélogramme.  

			\begin{center}
				\begin{tikzpicture}[node distance=2cm]
				\node (io) [io, text width=6cm] 
					{Afficher rectangleArea(122, 3.78)};
				\end{tikzpicture}
			\end{center}
	
		%-----------------------------------------
		\subsection{Demander des valeurs}
		\index{demander}\index{read}
		%-----------------------------------------
	
			Il serait maintenant intéressant de demander à l’utilisateur ce que
			valent la longueur et la largeur.  C’est le but de la commande
			\pc{\K{read}}. 

			\begin{langagenaturel}
				read length \\
				read width\\
				print rectangleArea(length, width)\\

				demander la valeur de length
			\end{langagenaturel}

			En langage naturel, nous pouvons choisir d'écrire lire, read,
			demander la valeur de… Dans ces notes, nous écrirons \pc{\K{read}}.
	
			L’instruction \pc{\K{read}} signifie que l’utilisateur va, à cet
			endroit de l’algorithme, être sollicité pour donner une valeur qui
			sera affectée à une variable.  À nouveau, la façon dont il va
			indiquer cette valeur (au clavier dans une application texte, via un
			champ de saisie ou une liste déroulante dans une application
			graphique, via une interface tactile, via des boutons physiques, via
			la reconnaissance vocale\dots) ne nous intéresse pas ici.

			En langage Java, trois instructions seront nécessaires pour 
			pouvoir faire une lecture au clavier pour un programme s'exécutant
			dans la console%
			\footnote{Pour une application graphique, c'est encore un 
			peu plus compliqué.}.

			\begin{java}
import java.util.Scanner;
// ...
Scanner keyboard = new Scanner(System.in);
// ...
double length = keyboard.nextDouble();
			\end{java}
	
		%-----------------------------------------
		\subsection{Préférer les paramètres}
		%-----------------------------------------
			
			Un algorithme avec paramètres est toujours plus intéressant qu’un
			algorithme qui demande les données et affiche le résultat car il
			peut être utilisé (appelé) dans un autre algorithme pour résoudre
			une partie du problème. C'est exactement pareil pour un programme;
			on privilégiera des méthodes recevant des valeurs en arguments que 
			des méthodes qui demandent les données à l'utilisateur. Cette demande
			sera faites à un autre moment. 

			L'exemple du rectangle pourrait s'écrire de manière un peu plus 
			complète comme suit~:

			\begin{java}
import java.util.Scanner;
				
public class AreaTest {
	/* 
	 * Calcule la surface d'un rectangle dont on donne la largeur et 
	 * la longueur.
	 * 
	 * Les données ne sont pas négatives.
	 */
	public static double rectangleArea(double length, double width){
		return length * width;
	}

	public static void main(String[] args){
		double length;
		double width;
		Scanner keyboard = new Scanner(System.in);

		System.out.println("Entre la longueur: ");
		length = keyboard.nextDouble();
		System.out.println("Entre la largeur: ");
		width = keyboard.nextDouble();

		System.out.println("Surface: " + rectangleArea(length, width));
	}
}

			\end{java}
