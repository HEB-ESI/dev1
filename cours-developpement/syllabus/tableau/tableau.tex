%======================
\chapter{Les tableaux}
%======================

	Dans ce chapitre nous étudions les tableaux, une structure qui peut contenir
	plusieurs exemplaires de même type.

	\minitoc
	\clearpage
	% =============================
	\section{Utilité des tableaux}
	% =============================
	
		Nous allons introduire la notion de tableau à partir d’un exemple 
		dans lequel l’utilité de cette structure de données 
		apparaitra de façon naturelle.
	
		\textbf{Exemple.}
		Statistiques de ventes.
		\begin{quote}	
		
			Un gérant d’une entreprise commerciale souhaite connaitre l’impact
			d’une journée de promotion publicitaire sur la vente de dix de ses
			produits.  
			
			Pour ce faire, les numéros de ces produits (numérotés de
			0 à 9 pour simplifier) ainsi que les quantités vendues pendant cette
			journée de promotion sont encodés au fur et à mesure de leurs
			ventes.  En fin de journée, le vendeur entrera la valeur -1 pour
			signaler la fin de l’introduction des données.  Ensuite, les
			statistiques des ventes seront affichées.
		
		\end{quote}

		La démarche générale se décompose en trois parties~:
		\begin{itemize}
		
			\item le traitement de début de journée, qui consiste
				essentiellement à mettre les compteurs des quantités vendues
				pour chaque produit à 0~;
		
			\item le traitement itératif durant toute la journée~: au fur et
				à mesure des ventes, il convient de les enregistrer,
				c’est-à-dire d’ajouter au compteur des ventes d’un produit la
				quantité vendue de ce produit~; ce traitement itératif
				s’interrompra lorsque la valeur -1 sera introduite~;
		
			\item le traitement final, consistant à communiquer les valeurs des
				compteurs pour chaque produit.
		
	\end{itemize}
	
		Vous trouverez sur la page suivante une version possible de cet
		algorithme sans utiliser les tabeaux.

		\begin{java}
import java.util.Scanner;
/*
 Calcule et affiche la quantité vendue de 10 produits
*/
public static void statistics(){
	Scanner keyboard = new Scanner(System.in);
	int cpt0, cpt1, cpt2, cpt3, cpt4, cpt5, cpt6, cpt7, cpt8, cpt9;
	int productId, quantity;
	cpt0 = 0;
	cpt1 = 0;
	cpt2 = 0;
	cpt3 = 0;
	cpt4 = 0;
	cpt5 = 0;
	cpt6 = 0;
	cpt7 = 0;
	cpt8 = 0;
	cpt9 = 0;
	System.out.print("Introduire le numéro de produit : ");
	productId = keyboard.nextInt();
	while (productId != -1){
		System.out.print("Quantité:");
		quantity = keyboard.nextInt();
		switch (productId){
			case 0:
				cpt0 = cpt0 + quantity;
				break;
			case 1:
				cpt1 = cpt1 + quantity;
				break;
			case 2:
				cpt2 = cpt2 + quantity;
				break;
			case 3:
				cpt3 = cpt3 + quantity;
				break;
			case 4:
				cpt4 = cpt4 + quantity;
				break;
			case 5:
				cpt5 = cpt5 + quantity;
				break;
			case 6:
				cpt6 = cpt6 + quantity;
				break;
			case 7:
				cpt7 = cpt7 + quantity;
				break;
			case 8:
				cpt8 = cpt8 + quantity;
				break;
			case 9:
				cpt9 = cpt9 + quantity;
				break;
		}
		System.out.print("Introduire le numéro de produit : ");
		productId = keyboard.nextInt();
	}

	\end{java}
	
	\begin{java}

	System.out.println("Quantité vendue de produit 0" + cpt0);
	System.out.println("Quantité vendue de produit 1" + cpt1);
	System.out.println("Quantité vendue de produit 2" + cpt2);
	System.out.println("Quantité vendue de produit 3" + cpt3);
	System.out.println("Quantité vendue de produit 4" + cpt4);
	System.out.println("Quantité vendue de produit 5" + cpt5);
	System.out.println("Quantité vendue de produit 6" + cpt6);
	System.out.println("Quantité vendue de produit 7" + cpt7);
	System.out.println("Quantité vendue de produit 8" + cpt8);
	System.out.println("Quantité vendue de produit 9" + cpt9);
 }
		\end{java}
	

		\index{tableau}
		Que se passerait-il si le nombre de produits à traiter était de 20, voire
		1000~? Une simplification de l'écriture s'impose.  La solution est
		apportée par un nouveau type de variables~: les \textbf{variables
		indicées} ou \textbf{tableaux} (\textit{arrays} en anglais).
	
		Au lieu d’avoir à manier dix compteurs distincts
		(\pc{cpt0}, \pc{cpt1}, etc.), 
		nous allons envisager une seule «~grande~» variable 
		\pc{cpt} compartimentée en dix «~cases~» ou «~sous-variables~»
		(appelées aussi les «~éléments~» du tableau). 
		Elles se distingueront les unes des autres par un numéro 
		(un «~indice~»)~: 
		\pc{cpt0} deviendrait ainsi \pc{cpt[0]}, 
		\pc{cpt1} deviendrait \pc{cpt[1]}, 
		et ainsi de suite jusqu’à
		\pc{cpt9} qui deviendrait \pc{cpt[9]}.
	
		\begin{center}
			\begin{tabular}{*{11}{>{\centering\arraybackslash}m{5mm}}}
				{} &
				\pc{cpt[0]} &
				\pc{cpt[1]} &
				\pc{cpt[2]} &
				\pc{cpt[3]} &
				\pc{cpt[4]} &
				\pc{cpt[5]} &
				\pc{cpt[6]} &
				\pc{cpt[7]} &
				\pc{cpt[8]} &
				\pc{cpt[9]} 
				\\\hhline{~*{10}{-}}
				\multicolumn{1}{m{5mm}|}{\pc{cpt}} &
				\multicolumn{1}{m{5mm}|}{~} &
				\multicolumn{1}{m{5mm}|}{~} &
				\multicolumn{1}{m{5mm}|}{~} &
				\multicolumn{1}{m{5mm}|}{~} &
				\multicolumn{1}{m{5mm}|}{~} &
				\multicolumn{1}{m{5mm}|}{~} &
				\multicolumn{1}{m{5mm}|}{~} &
				\multicolumn{1}{m{5mm}|}{~} &
				\multicolumn{1}{m{5mm}|}{~} &
				\multicolumn{1}{m{5mm}|}{~}
				\\\hhline{~*{10}{-}}
			\end{tabular}
		\end{center}
	
		Un des intérêts de cette notation est la possibilité de faire apparaitre
		une variable entre les crochets, par exemple \pc{cpt[i]}, ce qui permet
		une grande économie de lignes de code.
		
		Voici la version de notre solution avec tableau.
	
		\label{tableau:tab1DStock10Articles}
		\begin{java}
import java.util.Scanner;
public static void statisticsWithArray(){
	Scanner keyboard = new Scanner(System.in);
	int[] cpt = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
	int i;
	int productId;
	int quantity;
	System.out.print("Introduire le numéro de produit : ");
	productId = keyboard.nextInt();
	while (productId != -1){
		System.out.print("Quantité:");
		quantity = keyboard.nextInt();
	
		cpt[productId] = cpt[productId] + quantity;

		System.out.print("Introduire le numéro de produit : ");
		productId = keyboard.nextInt();		
	}

	for(int i=0; i<10; i++){
		System.out.println("Quantité vendue de produit " i + ": " + cpt[i]);		
	}
}
			
		\end{java}

		
	% ====================
	\section{Définitions}
	% ====================
	
		\marginicon{definition}\index{tableau}
		Un \textbf{tableau} est une suite d’éléments de même type 
		portant tous le même nom mais se distinguant 
		les uns des autres par un indice.
	
		L’\textbf{indice} est un entier\index{tableau (indice)}
		donnant la position d’un élément dans la suite. 
		Cet indice varie entre la position du premier élément 
		et la position du dernier élément, 
		ces positions correspondant aux bornes de l’indice.
		Notons qu’il n’y a pas de «~trou~»~: 
		tous les éléments existent entre le premier et le dernier indice.
	
		La \textbf{taille} d’un tableau\index{tableau (taille)} est le nombre de
		ses éléments.  Attention, la taille d’un tableau ne peut pas être
		modifiée pendant son utilisation, elle est déterminée à la création du
		tableau.

		Un tableau est de type \textbf{référence}\index{référence}.
	
	% ======================================================
	\section{Déclaration - création - initialisation}
	% ======================================================

		\marginicon{definition}
		Afin de pouvoir utiliser un tableau, il sera nécessaire de distinguer~:
		\begin{itemize}

			\item la \textbf{déclaration} qui consiste à signaler qu'une
				variable est un tableau. Dans un programme, cette déclaration
				a pour effet de réserver un emplacement mémoire qui contiendra
				une référence vers les cases du tableau\,; 

			\item la \textbf{création} du tableau consiste a réserver
				l'emplacement mémoire qui contiendra les différentes valeurs.
				Pour le créer, il faut connaitre sa taille\,; 

			\item l'\textbf{initialisation} du tableau consiste à donner ses
				premières valeurs aux différents éléments du tableau.
		
		\end{itemize}


		\index{déclaration}
		\index{création}
		Nous supposerons dans la suite que \pc{length} est le nombre d’éléments
		—~la longueur~—
		et \pc{Type} est le type des éléments que l’on trouvera dans le tableau.  
		
		Tous les types sont permis mais tous les éléments sont du même type. 

		\subsection{Déclaration}
		\index{déclaration}

		Pour \textbf{déclarer} un tableau~:

	\begin{grammaire}
		\grammarrule{ArrayDeclarationExpression:}
		    \grammarrule{Type}[] \grammarrule{Identifier}
	\end{grammaire}

	\begin{java}
int[] myArray;
String[] strings;
	\end{java}

	Seule la variable est déclarée. Aucun espace mémoire n'est réservé pour
	recevoir les éléments du tableau. Ceci sera fait lors de la création du
	tableau.  

	\subsection{Création}
	\index{création}
		
	Pour \textbf{créer} un tableau, préalablement déclaré, nous écrirons~:

	\begin{grammaire}
		\grammarrule{ArrayCreationExpression:}
		    new \grammarrule{Type}[\grammarrule{Expression}]
	\end{grammaire}

	\begin{java}
myArray = new int[10];
strings = new String[3];
	\end{java}

	L'emplacement mémoire nécessaire pour stocker la valeur de chaque élément
	du tableau est réservé. 

	\subsection{Initialisation}
	\index{initialisation}

	Pour \textbf{initialiser} les éléments du tableau, nous pouvons le faire en
	accédant à chaque élément du tableau. Un par un. 
	
	L'accès aux éléments d'un tableau se fait grâce aux crochets
	\pc{myArray[i]} pour nos algorithmes, en langage Java et dans beaucoup
	d'autres langages. Comme suit~:

	\begin{java}
		myArray[0] = 5;
		strings[1] = "Hello";
	\end{java}

	La première case du tableau porte l’indice \pc{0}
	la dernière l’indice \pc{size-1}.  C’est une erreur
	d’indiquer un indice qui ne correspond pas à une case du tableau (trop petit
	ou trop grand).  Par exemple, si on déclare et crée le tableau \pc{myArray}~:

	\begin{java}
int[] myArray = new int[100];
	\end{java}
	c'est une erreur d’utiliser \pc{myArray[-1]} ou \pc{myArray[100]}. 

	Il est également possible d'initialiser un tableau en une seule fois, en 
	utilisant un \textit{array initializer}. Une notation entre accolades. 

	\begin{langagenaturel}
myArray = \{2, 3, 7\}
	\end{langagenaturel}

	Voici la grammaire Java. 

	\begin{grammaire}
		\grammarrule{ArrayInitializer:}
		    \{ \grammarrule{[VariableInitializerList]} \}

		\grammarrule{VariableInitializerList:}
		    \grammarrule{Expression} \grammarrule{[}, \grammarrule{Expression ]} 
	\end{grammaire}

	\begin{java}
		int[] myArray;
		myArray = new int[3];
		myArray[0] = 2;
		myArray[1] = 3;
		myArray[2] = 7;

		myArray = new int[] {-1, 3, 12, 5};

		int[] myArray2 = {3, 14, 15, 92};
		
	\end{java}

	\begin{description}

		\item[ligne 7] Pour utiliser un \textit{ArrayInitializer}, il faut créer
			et initialiser le tableau dans la même instruction. Dans ce cas, le
			langage interdit de renseigner le nombre d'éléments du tableau… le
			compilateur peut le déduire.

			Cette instruction crée un nouveau tableau qui écrase l'autre. 

		\item[ligne 9] Lorsque l'on initialise le tableau avec un
			\textit{ArrayInitializer} lors de la déclaration, la partie création
			peut être omise.
	
	\end{description}

	\paragraph{Remarque.} Chaque élément d’un tableau doit être manié avec la
	même précaution qu’une variable simple, c’est-à-dire qu’on ne peut utiliser
	un élément du tableau qui n’aurait pas été préalablement affecté ou
	initialisé.

		

	% ==============================
	\section{Tableau et paramètres}
	% ==============================
	
		Le type \emph{tableau} étant un type à part entière, il est tout-à-fait
		éligible comme type pour les paramètres et la valeur de retour d’un
		algorithme.  De manière générale là où pouvait apparaitre un type
		(entier, pseudo-réel…) peut apparaitre un tableau.  Toujours.  Voyons
		cela en détail.  

		Nous avons vu dans la section \ref{paramètres} p.~\pageref{paramètres}
		les différentes sortes de paramètres. Voyons ce qu'il en est pour
		chacun d'eux lorsque ce paramètre est un tableau. 


		\subsection{Un tableau comme paramètre en entrée}
				
		\In : indique que l’algorithme va consulter les valeurs du tableau reçu
		en paramètre.  Les éléments doivent donc avoir été initialisés avant
		d’appeler l’algorithme. Exemple~:
			
		\begin{pseudocode}
			\LComment{Affiche les éléments d’un tableau}
			\Algo{display}{\Par{myArray\In}{\Array{10}{integers}}}{} 
				\For{i}{0}{9}
					\Write myArray[i]
				\EndFor
			\EndAlgo 

			\Empty
			\LComment{Utilisations possible}
			\Decl{anArray}{\Array{10}{integers}}
			\Let anArray \Gets \{2,3,5,7,11,13,17,19,23,29\}
			\Stmt display(anArray)
		\end{pseudocode}
	

		\subsection{Un tableau comme paramètre en entrée-sortie}

		\In\Out : indique que l’algorithme va consulter/modifier les valeurs du
		tableau reçu en paramètre. Exemple~:
			
		\begin{pseudocode}
			\LComment{Inverse le signe des éléments du tableau}
			\Algo{reverseSigne}{\Par{myArray\In\Out}{\Array{10}{integers}}}{} 
				\For{i}{0}{9}
					\Let myArray[i] \Gets -myArray[i]
				\EndFor
			\EndAlgo 

			\Empty
			\LComment{Utilisation possible}
			\Decl{anArray}{\Array{}{integers}}
			\Let anArray \Gets	
				{\Array{}{integers}}
				\{2,-3,5,-7,11,13,17,-19,23,29\}
			\Stmt reverseSigne(anArray)
		\end{pseudocode}


		\subsection{Un tableau comme paramètre en langage Java}

		En langage Java, le passage de paramètres se fait toujours par valeur.
		Comme un tableau est de type référence, c'est bien la valeur de la
		référence qui est passée en paramètre. En ce sens, il sera possible de
		modifier les valeurs d'un tableau reçu mais pas de remplacer le tableau
		reçu par un autre. Exemples~:

\begin{java}
	public static void reverseSigne(int[] is){
		for (int i=0; i < is.length; i = i + 1){
			is[i] = -is[i];
		}
	}

	// Utilisation
	int[] myArray = {2,-3,5,-7,11,13,17,-19,23,29};
	reverseSigne(myArray);
\end{java}

\marginicon{dont}
\begin{java}
	public static void fail(double[] ds){
		ds = new double[] {2, 2.61};
	}


	// Utilisation
	double[] myArray = {1, 3.14};
	fail(myArray);
	// 3.14 et pas 2.61
	System.out.println("Value: " + myArray[1]);		

\end{java}



		\subsection{Un tableau comme type de retour}

		Comme pour n’importe quel autre type, un algorithme ou un programme peut
		retourner un tableau.  Ce sera à lui de le déclarer et de lui donner des
		valeurs.  Exemple~:
			

\begin{java}
	public static int[] create(){
		int[] myArray = new int[10];
		for (int i=0; i < 10; i = i + 1){
			myArray[i] = i;
		}
		return myArray;
	}


	// Utilisation possible
	int[] anArray = create();
\end{java}

		\subsection{Paramétrer la taille}
		%---------------------------------
		
		Un tableau connait sa taille dès lors qu'elle existe c'est-à-dire dès
		que le tableau est créé. La taille est accessible grâce au mot
		\pc{length} comme suit~:

		\begin{java}
			double[] myArray;
			int size = myArray.length;

			double[] otherArray = {3.14, 2.71};
			int otherSize = otherArray.length;
		\end{java}

		Un tableau peut être passé en paramètre à un algorithme ou à une méthode
		et ce, quelle que soit la taille du tableau passé en paramètre.
		L'algorithme ou la méthode aura comme paramètre un tableau qui connait
		sa taille. Lorsque l'algorithme ou la méthode recevra le paramètre
		effectif, la taille sera déterminée. 
		
		\textbf{Exemple~:}

		\begin{java}
public static void display(int[] myArray){
	System.out.println("Tableau de " 
		+ myArray.length 
		+ " éléments." );
	for (int i=0; i< myArray.length; i++){
		System.out.println(myArray[i]);
	}

	// Utilisations possibles
	int[] integers = new int[2];
	integers[0] = 56;
	integers[1] = -3;
	display(integers);
	
	int[] myBeautifulArray = {6, 12, 18};
	display(myBeautifulArray);
}
		\end{java}

		La fiche \vref{fiche:tab-passage-param} récapitule tout ça.

	% ==============================================
	\section{Parcours d’un tableau} 
	\label{Les parcours de tableaux}
	% ==============================================

		Dans la plupart des problèmes que vous rencontrerez vous serez amenés
		à parcourir un tableau.  Il est important de maitriser ce parcours.
		Examinons les situations courantes et voyons quelles solutions
		conviennent.
	
		\begin{description}

			\item[Parcours complet]
		
			Nous avons déjà vu dans les exemples comment parcourir tous les
			éléments d’un tableau.  Une boucle \pc{for} fait généralement
			l'affaire comme ceci~:

			\begin{java}
int[] myArray = { /* insert values */ };
for (int index = 0; index < myArray.length; index++){
	// do something with myArray[index]
}
			\end{java}

			Java propose une autre forme de \pc{for} —~l'\textit{enhanced for}
			ou \textit{foreach}\index{foreach}~— permettant de parcourir un
			tableau\footnote{Nous verrons en DEV2, que cette structure permet
			de parcourir d'autres choses que les tableaux.}

			\begin{java}
int[] myArray = { /* insert values */ };
for (int value: myArray){
	// do something with value
}
			\end{java}
			
			La fiche \vref{fiche:tab-parcours-complet} décrit
			comment afficher tous les éléments d’un tableau.  Il est possible de
			faire autre chose avec ces éléments~: les sommer, les comparer\dots

			\item[Parcours partiel]
		
			Parfois, il n'est pas nécessaire de parcourir le tableau jusqu’au
			bout car un arrêt prématuré survient dès qu'une condition est
			remplie. 
			
			Par exemple~: recherche d'un élément et arrêt dès qu'il est trouvé~;
			vérification que toutes les valeurs sont non nulles mais l'on vient
			d'en trouver une~; vérification que la suite des éléments est
			positives alors que l'on vient d'en trouver un négatif ou nul.
	
			Pour résoudre ce problème, la structure \pc{tant que} avec un test
			d'arrêt fait bien l'affaire. 
			
			La fiche \vref{fiche:tab-parcours-partiel} détaille un parcours
			partiel.
	
		\end{description}
	
	% ==============================================
	\section{Taille logique\index{taille logique} et 
	taille physique\index{taille physique}} 
	% ==============================================

		Parfois, la taille du tableau n'est pas connue à l'avance.
		
		Imaginons, par exemple, qu’il s’agisse de demander des valeurs
		à l’utilisateur et de les stocker dans un tableau pour un traitement
		ultérieur.  Supposons que l’utilisateur va indiquer la fin des données
		par une valeur sentinelle.  Impossible de savoir, à priori, combien de
		valeurs il va entrer et, par conséquent, la taille à donner au tableau.
		
		Une solution est de créer un tableau suffisamment grand
		pour tous les cas%
		\footnote{%
			En tout cas, 
			suffisamment grand pour tous les cas qu’on accepte
			de prendre en compte; il faudra bien fixer une limite.
		} 
		quitte à n’en n’utiliser qu’une partie.
		
		Mais comment savoir quelle est la partie du tableau
		qui est effectivement utilisée~?
		
		Comprenez bien qu’il \textbf{n’y a pas de concept de case vide}.  Rien
		ne différencie une case utilisée d’une case non utilisée.  La manière de
		s'en sortir est de stocker les valeurs dans la partie basse du tableau
		(à gauche) et de retenir dans une variable le nombre de cases
		effectivement utilisées.
			
		\marginicon{definition}
		La \textbf{taille physique} d’un tableau 
		est le nombre de cases qu’il contient.
		Sa \textbf{taille logique}
		est le nombre de cases actuellement utilisées.
	
		\paragraph{Exemple.}
		Voici un tableau qui ne contient pour l’instant que quatre nombres.
		\begin{center}
			\begin{tabular}{*{10}{|>{\centering\arraybackslash}m{5mm}}|}
				\hline
				10 & 4 & 3 & 7 & ? & ? & ? & ? & ? & ? \\
				\hline
			\end{tabular}
			\\\medskip
			\pc{taillePhysique = 10}
			\qquad
			\pc{tailleLogique = 4}
		\end{center}

		Les cases indiquées par "?" ne sont pas vides~;
		elles peuvent être non initialisées
		(et il n'est pas possible de tester si une case est non initialisée)
		ou bien contenir une valeur qui n’est pas pertinente.
		
		\paragraph{Exemple.}
		L’algorithme suivant demande des valeurs positives à l’utilisateur et
		les stocke dans un tableau (maximum 1000).  Toute valeur négative ou
		nulle est une valeur sentinelle.

		\begin{java}
public static void stockValues(){
	Scanner keyboard = new Scanner(System.in);
	int[] myArray = new int[1000];
	int nbValues = 0;
	int value;
	value = keyboard.nextint();
	while (value > 0 && nbValues < myArray.length){
		myArray[nbValues] = value;
		nbValues++;
		value = keyboard.nextint();
	}
	// Test de value et pas de nbValues. Pourquoi ?
	if (value > 0){
		System.out.println("La limite physique a été atteinte");
	}
}			
		\end{java}
		
		En langage Java, essayer d'ajouter un élément en dehors de la taille du
		tableau va générer une erreur à l'exécution. Une
		\pc{ArrayIndexOutOfBoundException}. 

		
	% ==============================================
	\section{Les tableaux ont comme premier indice 0} 
	% ==============================================

		Les tableaux ont comme premier indice 0, Un tableau de taille \pc{n}
		a toujours ses indices allant de \pc{0} à \pc{n-1}. 

		Parfois le problème à résoudre donne envie d'avoir des indices dont le
		premier ne commence pas à 0. Par exemple allant de 1 à 7. Dans ces cas,
		il est toujours possible de s'arranger pour commencer à partir de 0. 

		\paragraph{Exemple.}
		Imaginons l’algorithme qui permet de convertir un numéro
		de jour en son intitulé~: 1 donne "lundi", 2 donne "mardi",
		\dots{}
		Une solution possible, sans tableau, serait~:
		
		\begin{java}
public static String dayName(int dayNumber){
	String dayName;
	switch (dayNumber){
		case 1:
			dayName = "lundi";
			break;
		case 2:
			dayName = "mardi";
			break;
		case 3:
			dayName = "mercredi";
			break;
		case 4:
			dayName = "jeudi";
			break;
		case 5:
			dayName = "vendredi";
			break;
		case 6:
			dayName = "samedi";
			break;
		case 7:
			dayName = "dimanche";
			break;
		default:
			dayName = "inconnu";
	}
	return dayName;
}
		\end{java}

		Mais une solution plus élégante passe par l’utilisation d’un tableau.
		Appelons-le \pc{dayString} et stockons-y les noms des jours
		comme illustré ci-dessous.

		\begin{center}
			\footnotesize
			\begin{tabular}{ccccccc}
				1 & 2 & 3 & 4 & 5 & 6 & 7
				\\\hline
				\multicolumn{1}{|c|}{"lundi"} &
				\multicolumn{1}{c|}{"mardi"} &
				\multicolumn{1}{c|}{"mercredi"} &
				\multicolumn{1}{c|}{"jeudi"} &
				\multicolumn{1}{c|}{"vendredi"} &
				\multicolumn{1}{c|}{"samedi"} &
				\multicolumn{1}{c|}{"dimanche"}
				\\\hline
			\end{tabular}
		\end{center}


		Si le tableau commence à l'indice 1 jusqu'à l'indice 7, pour obtenir le
		nom d’un jour, il suffirait d’écrire~: \pc{dayString[dayNumber]}.
		
		Comme les tableaux commencent toujours à l'indice 0, il faudra plutôt
		considérer le tableau ci-dessous et écrire \pc{dayString[dayNumber-1]}.
		
		\begin{center}
			\footnotesize
			\begin{tabular}{ccccccc}
				0 &1 & 2 & 3 & 4 & 5 & 6 
				\\\hline
				\multicolumn{1}{|c|}{"lundi"} &
				\multicolumn{1}{c|}{"mardi"} &
				\multicolumn{1}{c|}{"mercredi"} &
				\multicolumn{1}{c|}{"jeudi"} &
				\multicolumn{1}{c|}{"vendredi"} &
				\multicolumn{1}{c|}{"samedi"} &
				\multicolumn{1}{c|}{"dimanche"}
				\\\hline
			\end{tabular}
		\end{center}

		
		
